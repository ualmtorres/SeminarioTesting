<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Servicio de las Tecnologías de la Información y las Comunicaciones - Universidad de Almería">
<title>Testing de APIs NestJS (tutorial en curso)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-right data-line-1">
<div id="header">
<h1>Testing de APIs NestJS (tutorial en curso)</h1>
<div class="details">
<span id="author" class="author">Servicio de las Tecnologías de la Información y las Comunicaciones - Universidad de Almería</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de contenidos</div>
<ul class="sectlevel1">
<li><a href="#_resumen">Resumen</a></li>
<li><a href="#_introducción">1. Introducción</a></li>
<li><a href="#_introducción_al_testing_con_la_kata_fizz_buzz">2. Introducción al testing con la kata Fizz Buzz</a>
<ul class="sectlevel2">
<li><a href="#_pruebas_en_nestjs">2.1. Pruebas en NestJS</a></li>
<li><a href="#_el_archivo_de_tests_app_controller_spec_ts">2.2. El archivo de tests <code>app.controller.spec.ts</code></a>
<ul class="sectlevel3">
<li><a href="#_la_función_it">2.2.1. La función <code>it</code></a></li>
<li><a href="#_agrupación_de_tests_mediante_describe">2.2.2. Agrupación de tests mediante <code>describe</code></a></li>
<li><a href="#_la_función_beforeeach">2.2.3. La función <code>beforeEach</code></a></li>
</ul>
</li>
<li><a href="#_implementación_de_la_kata_fizz_buzz">2.3. Implementación de la kata Fizz Buzz</a></li>
<li><a href="#_pruebas_unitarias_del_servicio">2.4. Pruebas unitarias del servicio</a></li>
<li><a href="#_cobertura_de_tests">2.5. Cobertura de tests</a>
<ul class="sectlevel3">
<li><a href="#_exclusión_de_archivos_de_la_cobertura_de_tests">2.5.1. Exclusión de archivos de la cobertura de tests</a></li>
</ul>
</li>
<li><a href="#_pruebas_unitarias_del_controlador">2.6. Pruebas unitarias del controlador</a>
<ul class="sectlevel3">
<li><a href="#_mockeo_mediante_jest_spyon">2.6.1. Mockeo mediante <code>jest.spyOn</code></a></li>
<li><a href="#_mockeado_del_servicio_completo">2.6.2. Mockeado del servicio completo</a></li>
</ul>
</li>
<li><a href="#_pruebas_de_integración">2.7. Pruebas de integración</a></li>
</ul>
</li>
<li><a href="#_caso_de_uso_reserva_de_espacios">3. Caso de uso. Reserva de espacios</a>
<ul class="sectlevel2">
<li><a href="#_primeros_tests">3.1. Primeros tests</a></li>
<li><a href="#_tests_del_controlador_de_solicitudes">3.2. Tests del controlador de solicitudes</a>
<ul class="sectlevel3">
<li><a href="#_primer_paso_evitar_que_falle_el_test">3.2.1. Primer paso. Evitar que falle el test</a></li>
<li><a href="#_segundo_paso_añadir_tests">3.2.2. Segundo paso. Añadir tests</a></li>
<li><a href="#_tercer_paso_llevar_el_mock_del_servicio_a_una_clase">3.2.3. Tercer paso. Llevar el mock del servicio a una clase</a></li>
</ul>
</li>
<li><a href="#_tests_del_servicio">3.3. Tests del servicio</a>
<ul class="sectlevel3">
<li><a href="#_primer_paso_evitar_que_falle_el_test_2">3.3.1. Primer paso. Evitar que falle el test</a></li>
<li><a href="#_segundo_paso_añadir_tests_2">3.3.2. Segundo paso. Añadir tests</a></li>
<li><a href="#_tercer_paso_llevar_el_mock_del_repositorio_a_una_clase">3.3.3. Tercer paso. Llevar el mock del repositorio a una clase</a></li>
</ul>
</li>
<li><a href="#_tests_end_to_end">3.4. Tests end to end</a>
<ul class="sectlevel3">
<li><a href="#_añadir_script_para_tests_e2e_en_modo_watch">3.4.1. Añadir script para tests e2e en modo <code>watch</code></a></li>
<li><a href="#_primer_paso_evitar_que_falle_el_test_3">3.4.2. Primer paso. Evitar que falle el test</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_caso_de_uso_catálogo_de_productos">4. Caso de uso. Catálogo de productos</a>
<ul class="sectlevel2">
<li><a href="#_primeros_tests_2">4.1. Primeros tests</a></li>
<li><a href="#_tests_del_controlador">4.2. Tests del controlador</a>
<ul class="sectlevel3">
<li><a href="#_primer_paso_evitar_que_falle_el_test_4">4.2.1. Primer paso. Evitar que falle el test</a></li>
<li><a href="#_segundo_paso_añadir_tests_3">4.2.2. Segundo paso. Añadir tests</a></li>
<li><a href="#_tercer_paso_llevar_el_mock_del_servicio_a_una_clase_2">4.2.3. Tercer paso. Llevar el mock del servicio a una clase</a></li>
</ul>
</li>
<li><a href="#_tests_del_servicio_2">4.3. Tests del servicio</a>
<ul class="sectlevel3">
<li><a href="#_primer_paso_evitar_que_falle_el_test_5">4.3.1. Primer paso. Evitar que falle el test</a></li>
<li><a href="#_segundo_paso_añadir_tests_4">4.3.2. Segundo paso. Añadir tests</a></li>
<li><a href="#_tercer_paso_llevar_el_mock_del_repositorio_a_una_clase_2">4.3.3. Tercer paso. Llevar el mock del repositorio a una clase</a></li>
</ul>
</li>
<li><a href="#_tests_end_to_end_2">4.4. Tests end to end</a>
<ul class="sectlevel3">
<li><a href="#_añadir_script_para_tests_e2e_en_modo_watch_2">4.4.1. Añadir script para tests e2e en modo <code>watch</code></a></li>
<li><a href="#_primer_paso_evitar_que_falle_el_test_6">4.4.2. Primer paso. Evitar que falle el test</a></li>
<li><a href="#_segundo_paso_añadir_tests_5">4.4.3. Segundo paso. Añadir tests</a></li>
</ul>
</li>
<li><a href="#_cobertura_de_tests_2">4.5. Cobertura de tests</a>
<ul class="sectlevel3">
<li><a href="#_ignorando_los_módulos_para_el_análisis_de_la_cobertura">4.5.1. Ignorando los módulos para el análisis de la cobertura</a></li>
<li><a href="#_análisis_de_la_cobertura">4.5.2. Análisis de la cobertura</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_anexo_i_plugin_coverage_gutters">Anexo I. Plugin Coverage Gutters</a></li>
<li><a href="#_anexo_ii_configuración_inicial_del_proyecto">Anexo II. Configuración inicial del proyecto</a>
<ul class="sectlevel2">
<li><a href="#_creación_de_la_entidad">Creación de la entidad</a></li>
<li><a href="#_configuración_de_typeorm">Configuración de TypeORM</a></li>
<li><a href="#_configuración_de_swagger">Configuración de Swagger</a></li>
<li><a href="#_dtos">DTOs</a></li>
<li><a href="#_implementación_de_los_métodos_del_servicio">Implementación de los métodos del servicio</a></li>
<li><a href="#_adaptación_de_los_parámetros_del_controlador">Adaptación de los parámetros del controlador</a></li>
</ul>
</li>
<li><a href="#_anexo_ii_bdd">Anexo II. BDD</a></li>
<li><a href="#_anexo_iii_ejemplos_de_tests">Anexo III. Ejemplos de tests</a></li>
<li><a href="#_domain_objects_vs_entities">Domain objects vs entities</a></li>
<li><a href="#_sorry_cypress">Sorry Cypress</a></li>
<li><a href="#_retales">Retales</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock data-line-19">
<div class="content">
<img src="./images/logocloudstic.png" alt="logocloudstic">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-26">
<h2 id="_resumen">Resumen</h2>
<div class="sectionbody">
<div class="paragraph data-line-30">
<p>El proceso de testing es una etapa fundamental en el desarrollo de cualquier proyecto serio. Permite dar un feedback inmediato al equipo de desarrollo y hace tener más confianza en la aplicación y durante los procesos de refactorización. NestJS hace el proceso de desarrollo de tests sea más sencillo integrando Jest y Supertest sin configuración al crear un proyecto nuevo. Además, el uso del sistema de inyección de dependencias de NestJS facilita el uso de mocks. En este tutorial se presenta el desarrollo de tests unitarios para controladores y servicios, y el desarrollo de tests de integración, todo sobre ejemplos en NestJS de una API de reserva de espacios.</p>
</div>
<div class="ulist data-line-36">
<div class="title">Objetivos</div>
<ul>
<li class="data-line-36">
<p>Introducir el proceso de testing en backend.</p>
</li>
<li class="data-line-37">
<p>Introducir el uso de Jest y Supertest como frameworks de testing.</p>
</li>
<li class="data-line-38">
<p>Crear tests unitarios y de integración en aplicaciones NestJS.</p>
</li>
<li class="data-line-39">
<p>Conocer la importancia de la cobertura de tests.</p>
</li>
<li class="data-line-40">
<p>Realizar los tests unitarios de controladores y servicios en una API REST.</p>
</li>
<li class="data-line-41">
<p>Utilizar mocks de servicios y de repositorios para la realización de tests unitarios.</p>
</li>
<li class="data-line-42">
<p>Usar mocks de función y mocks de clases.</p>
</li>
<li class="data-line-43">
<p>Realizar tests de integración.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip data-line-46">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph data-line-47">
<p>Disponibles los repositorios usados en este tutorial.</p>
</div>
<div class="ulist data-line-49">
<ul>
<li class="data-line-49">
<p><a href="https://github.com/ualmtorres/fizzbuzz" data-href="https://github.com/ualmtorres/fizzbuzz">Fizz Buzz</a></p>
</li>
<li class="data-line-50">
<p><a href="https://github.com/ualmtorres/nestjs-espacios/tree/base" data-href="https://github.com/ualmtorres/nestjs-espacios/tree/base">Base del caso de uso de la API de gestión de espacios para el tutorial (Rama <code>base</code>)</a></p>
</li>
<li class="data-line-51">
<p><a href="https://github.com/ualmtorres/nestjs-espacios/tree/master" data-href="https://github.com/ualmtorres/nestjs-espacios/tree/master">Caso de uso de la API de gestión de espacios para el tutorial (Rama <code>master</code>)</a> (<strong>en curso</strong>)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-57">
<h2 id="_introducción">1. Introducción</h2>
<div class="sectionbody">
<div class="ulist data-line-59">
<ul>
<li class="data-line-59">
<p>Proceso necesario en cualquier proyecto software serio.</p>
</li>
<li class="data-line-60">
<p>Un test es un código que comprueba tu código. Hacen tener más confianza en la aplicación. Previenen arreglar una cosa sin romper otra. Queremos que ni nuestro yo del futuro ni otras personas rompan el código que hemos escrito hoy.</p>
</li>
<li class="data-line-61">
<p>La automatización de tests facilita la repetición de tests o suites de test de forma rápida y sencilla durante el desarrollo.</p>
</li>
<li class="data-line-62">
<p>Da un feedback inmediato a los desarrolladores.</p>
</li>
<li class="data-line-63">
<p>Facilita la refactorización chequeando el funcionamiento correcto del código refactorizado.</p>
</li>
<li class="data-line-64">
<p>Permite la reproducción de casos complejos (fallos a ciertas horas, desde ciertos sitios, &#8230;&#8203;)</p>
</li>
<li class="data-line-65">
<p>Uso de sistemas de CI que permiten la creación de pipelines que permiten la ejecución automatizada de tests, creación del build, despliegue automatizado o manual, &#8230;&#8203;</p>
</li>
<li class="data-line-67">
<p>Tipos de testing</p>
<div class="ulist data-line-68">
<ul>
<li class="data-line-68">
<p>Tests unitarios. Son código que ayuda a asegurar que las partes de las aplicaciones funcionan de la forma esperada. La unidad testada puede ser una función, una clase, un módulo. Deben ser independientes unos de otros. Para una entrada, el test unitario comprueba el resultado. No contactan con el mundo exterior</p>
</li>
<li class="data-line-69">
<p>Tests de integración. Comprobamos la integración de nuestro sistema con algo de infraestructura (p.e. bases de datos, archivos, E/S, &#8230;&#8203;). Hacen llamadas a servicios externos. Las pruebas de integración normalmente cubren la prueba de un sistema (p.e. backend) aislándolo del resto.</p>
</li>
<li class="data-line-70">
<p>Tests end to end. También conocidas como pruebas funcionales, simulan condiciones reales. Se ejecutarían en un navegador (o similar) y cubren todos los sistemas funcionando juntos (p.e. frontend y backend). Simulan a un usuario en la aplicación (escribiendo, haciendo clics, &#8230;&#8203;)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock data-line-72">
<div class="content">
<img src="./images/piramide-testing.png" alt="piramide testing">
</div>
</div>
<div class="paragraph data-line-74">
<p>La pirámide de tests, además de representar el coste y la velocidad de ejecucuión de los tests, también refleja que deberíamos escribir más tests de los simples (unitarios) y menos tests de los complejos (end-to-end).</p>
</div>
<div class="sidebarblock data-line-77">
<div class="content">
<div class="title">Nuestras herramientas de Testing</div>
<div class="paragraph data-line-78">
<p>Para nuestro trabajo de testing de aplicaciones con tecnología JavaScript/TypeScript, en UAL STIC se proponen las herramientas de testing siguientes:</p>
</div>
<div class="ulist data-line-80">
<ul>
<li class="data-line-80">
<p><a href="https://jestjs.io/" data-href="https://jestjs.io/">Jest</a> para tests unitarios en backend (pruebas de objetos de dominio, controladores y servicios) así como en frontend.</p>
</li>
<li class="data-line-81">
<p><a href="https://github.com/visionmedia/supertest" data-href="https://github.com/visionmedia/supertest">Supertest</a> para tests de integración en backend y frontend. Permite hacer las pruebas de llamadas HTTP.</p>
</li>
<li class="data-line-82">
<p><a href="https://www.cypress.io/" data-href="https://www.cypress.io/">Cypress</a> para pruebas e2e que simulen las acciones de los usuarios.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-86">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph data-line-87">
<p>El código de los tests tiene que ser fácil de mantener y tiene que centrarse en el resultado del método probado. Después de crear un test nos debemos preguntar lo siguiente: si un día se refactoriza el método probado (sin cambiar su resultado), ¿tendré que cambiar el test? Si la respuesta es sí, hay que modificar el test. Posiblemente en el test nos estemos centrando en detalles del proceso que no deberían de estar en el test.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-90">
<h2 id="_introducción_al_testing_con_la_kata_fizz_buzz">2. Introducción al testing con la kata Fizz Buzz</h2>
<div class="sectionbody">
<div class="paragraph data-line-92">
<p>Para introducirnos al mundo de testing lo haremos de la mano de la <a href="https://kata-log.rocks/fizz-buzz-kata" data-href="https://kata-log.rocks/fizz-buzz-kata">kata Fizz Buzz</a>. Se trata de un ejemplo sencillo en que para números comprendidos entre 1 y 100:</p>
</div>
<div class="ulist data-line-94">
<ul>
<li class="data-line-94">
<p>Se devolverá <em>Fizz</em> si el número es múltiplo de 3.</p>
</li>
<li class="data-line-95">
<p>Se devolverá <em>Buzz</em> si es múltiplo de 5.</p>
</li>
<li class="data-line-96">
<p>Se devolverá <em>Fizzbuzz</em> si es múltiplo de 15.</p>
</li>
<li class="data-line-97">
<p>En cualquier otro caso, se devolverá el propio número.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-99">
<p>Comencemos creando el proyecto NestJS.</p>
</div>
<div class="listingblock data-line-102">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ nest new fizzbuzz</code></pre>
</div>
</div>
<div class="paragraph data-line-106">
<p>Al crear un proyecto nuevo, NestJS instala las dependencias para testing y crea una suite de pruebas con un test de ejemplo para probar que la llamada a <code>/</code> devuelve <code>Hello World!</code>.</p>
</div>
<div class="paragraph data-line-108">
<p>Comenzamos probando el código de ejemplo creado por NestJS.</p>
</div>
<div class="listingblock data-line-111">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ cd fizzbuzz
$ npm run test</code></pre>
</div>
</div>
<div class="listingblock data-line-117">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">El resultado es el siguiente y nos informa que se han pasado los tests con éxito.

 PASS  src/app.controller.spec.ts
  AppController
    root
      ✓ should return "Hello World!" (14 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        4.162 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="sect2 data-line-132">
<h3 id="_pruebas_en_nestjs">2.1. Pruebas en NestJS</h3>
<div class="paragraph data-line-134">
<p>Como acabamos de comentar, el CLI de NestJS instala las dependencias de testing y crea una suite de pruebas a modo de ejemplo al crear un proyecto nuevo. Y es que NestJS ayuda a que el proceso sea menos tedioso ofreciendo lo siguiente:</p>
</div>
<div class="ulist data-line-136">
<ul>
<li class="data-line-136">
<p>Realiza un <em>scaffolding</em> para tests en la aplicación. Cuando creamos controladores y servicios, el CLI de NestJS también crea su correspondiente archivo de testing para dichos controladores y servicios. Al crear el proyecto, el CLI de NestJS también crea un archivo de testing e2e para probar la llamada a la ruta raíz de la aplicación.</p>
</li>
<li class="data-line-137">
<p>Integracion con <a href="https://github.com/facebook/jest" data-href="https://github.com/facebook/jest">Jest</a> (desarrollado por Facebook y se usa con "cero configuración") y <a href="https://github.com/visionmedia/supertest" data-href="https://github.com/visionmedia/supertest">Supertest</a> (para testing de peticiones HTTP). No obstante, se puede usar cualquier otro framework de testing.</p>
</li>
<li class="data-line-138">
<p>Uso del sistema de inyección de dependencias de NestJS para facilitar el uso de mocks. Por ejemplo, esto nos va a poder permitir proporcionar un servicio mockeado al probar un controlador.</p>
</li>
<li class="data-line-139">
<p>Jest se configura a través del archivo <code>package.json</code> determinando mediante expresiones regulares los archivos que se consideran tests (p.e. para que las pruebas estuviesen en cualquier archivo <code>.spec.ts</code> usaríamos <code>"testRegex": ".*\\.spec\\.ts$"</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-141">
<h3 id="_el_archivo_de_tests_app_controller_spec_ts">2.2. El archivo de tests <code>app.controller.spec.ts</code></h3>
<div class="paragraph data-line-143">
<p>Al crear un proyecto nuevo, el CLI de NestJS crea el archivo de testing <code>app.controller.spec.ts</code> como el siguiente.</p>
</div>
<div class="imageblock data-line-145">
<div class="content">
<img src="./images/EstructuraArchivoTest.png" alt="EstructuraArchivoTest">
</div>
</div>
<div class="paragraph data-line-147">
<p>En la figura vemos una característica muy interesante del testing en NestJS y es que permite la creación de módulos para el testing sobre la marcha (gracias a la inyección de dependencias). Esto permitirá configurar <em>ad-hoc</em> las dependencias necesarias para la ejecución de los tests. Y no se trata sólo de importar o usar módulos o providers previamente creados en la aplicación, sino que a la hora de configurar el módulo para la ejecución de los tests podemos <em>mockear</em> lo que queramos (servicios, repositorios para bases de datos, &#8230;&#8203;) sustituyendo la implementación original por un <em>mock</em> para el desarrollo de los tests. Esto lo veremos más adelante en <a href="#_pruebas_unitarias_del_controlador">Pruebas unitarias del controlador</a>.</p>
</div>
<div class="paragraph data-line-149">
<p>A continuación presentaremos las partes más significativas de ese archivo.</p>
</div>
<div class="sect3 data-line-151">
<h4 id="_la_función_it">2.2.1. La función <code>it</code></h4>
<div class="paragraph data-line-153">
<p>En Jest, los tests se implementan mediante funciones <code>it</code> (realmente, <code>it</code> es un alias de una función denominada <code>test</code>, y se pueden usar de forma indistinta). La función <code>it</code> toma 3 argumentos:</p>
</div>
<div class="ulist data-line-155">
<ul>
<li class="data-line-155">
<p>Nombre del test</p>
</li>
<li class="data-line-156">
<p>Función con las expectativas</p>
</li>
<li class="data-line-157">
<p>Timeout (opcional). El timeout predeterminado es de 5 segundos.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-159">
<p>A continuación se muestra el test generado por NestJS en <code>app.controller.spec.ts</code> al crear el proyecto.</p>
</div>
<div class="listingblock data-line-162">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">it( <b class="conum">(1)</b>
  'should return "Hello World!"', <b class="conum">(2)</b>
  () =&gt; { <b class="conum">(3)</b>
    expect(appController.getHello()).toBe('Hello World!'); <b class="conum">(4)</b>
  }
);</code></pre>
</div>
</div>
<div class="colist arabic data-line-173">
<ol>
<li>
<p>Definición del caso de prueba</p>
</li>
<li>
<p>Nombre del caso de prueba</p>
</li>
<li>
<p>Función de evaluación del test con la definición de las expectativas</p>
</li>
<li>
<p><code>expect</code> se usa para comprobar un valor obtenido por una <a href="https://jestjs.io/docs/expect" data-href="https://jestjs.io/docs/expect">función matcher</a>, como <code>toBe</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note data-line-176">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-177">
<p>El usar <code>it</code> en lugar de <code>test</code>, sumado a usar el nombre del test en condicional, hace que el test sea más legible: <code>it should return "Hello World!</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 data-line-180">
<h4 id="_agrupación_de_tests_mediante_describe">2.2.2. Agrupación de tests mediante <code>describe</code></h4>
<div class="paragraph data-line-182">
<p>Para tener un código de testing más limpio y organizado, los tests (<code>it</code>)  se pueden incluir en una función <code>describe</code>. Esto da lugar a un código de testing agrupado en bloques <code>describe</code>, los cuales están formados por tests <code>it</code>. Además, los bloques <code>describe</code> se pueden anidar. A continuación se muestra una estructura de agrupación de tests en bloques <code>describe</code>.</p>
</div>
<div class="listingblock data-line-185">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">  describe('root', () =&gt; { <b class="conum">(1)</b>
    it('should return "Hello World!"', () =&gt; { <b class="conum">(2)</b>
      expect(appController.getHello()).toBe('Hello World!');
    });

    it('should ....' () =&gt; { <b class="conum">(3)</b>
      // test code
    });
  });</code></pre>
</div>
</div>
<div class="colist arabic data-line-198">
<ol>
<li>
<p><code>describe</code> como agregador de tests</p>
</li>
<li>
<p>Primer test del bloque</p>
</li>
<li>
<p>Un segundo test del bloque</p>
</li>
</ol>
</div>
</div>
<div class="sect3 data-line-200">
<h4 id="_la_función_beforeeach">2.2.3. La función <code>beforeEach</code></h4>
<div class="paragraph data-line-202">
<p>La función <code>beforeEach</code> se ejecuta antes de que se ejecute cada test de la suite. Normalmente prepara una configuración que los tests necesitan para ejecutarse de forma independiente al resto de tests (p.e. prepara el contenido de la base de datos, configura un servicio para que devuelva unos datos concretos a los tests, &#8230;&#8203;)</p>
</div>
<div class="paragraph data-line-204">
<p>Esta función forma parte del conjunto de funciones de preparación o limpieza del entorno de testing:</p>
</div>
<div class="ulist data-line-206">
<ul>
<li class="data-line-206">
<p><code>beforeAll</code> se ejecuta una sola vez antes de todos los tests del bloque.</p>
</li>
<li class="data-line-207">
<p><code>beforeEach</code> se ejecuta antes de cada test del bloque.</p>
</li>
<li class="data-line-208">
<p><code>afterEach</code> se ejecuta después de cada test del bloque.</p>
</li>
<li class="data-line-209">
<p><code>afterAll</code> se ejecuta una sola vez después de todos los tests del bloque.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-211">
<h3 id="_implementación_de_la_kata_fizz_buzz">2.3. Implementación de la kata Fizz Buzz</h3>
<div class="paragraph data-line-213">
<p>Comenzamos creando un nuevo módulo, un servicio y un controlador para la kata.</p>
</div>
<div class="listingblock data-line-216">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">nest g module fizzbuzz
nest g service fizzbuzz
nest g controller fizzbuzz</code></pre>
</div>
</div>
<div class="paragraph data-line-222">
<p>En el servicio <code>fizzbuzz/fizzbuzz.service.ts</code> crearemos un nuevo método denominado <code>fizzbuzz</code> que aceptará un argumento de tipo <code>number</code>. El servicio tiene la lógica siguiente para implementar la <a href="https://kata-log.rocks/fizz-buzz-kata" data-href="https://kata-log.rocks/fizz-buzz-kata">kata Fizz Buzz</a>.</p>
</div>
<div class="listingblock data-line-226">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">import { Injectable } from '@nestjs/common';

@Injectable()
export class FizzbuzzService { <b class="conum">(1)</b>
  fizzbuzz(number): any {
    if (number &lt; 1 || number &gt; 100) {
      return;
    }

    if (number % 15 === 0) {
      return 'FizzBuzz';
    }

    if (number % 3 === 0) {
      return 'Fizz';
    }

    if (number % 5 === 0) {
      return 'Buzz';
    }

    return number;
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-252">
<ol>
<li>
<p>Método que implementa la kata Fizz Buzz</p>
</li>
</ol>
</div>
<div class="paragraph data-line-254">
<p>Para el controlador <code>fizzbuzz/fizzbuzz.controller.ts</code> crearemos un endpoint que acepte un número como parámetro. Este endpoint llamará al método del servicio del paso anterior.</p>
</div>
<div class="listingblock data-line-257">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Controller, Get, Param } from '@nestjs/common';
import { FizzbuzzService } from './fizzbuzz.service';

@Controller('fizzbuzz')
export class FizzbuzzController {
  constructor(private fizzbuzzService: FizzbuzzService) {}

  @Get(':number') <b class="conum">(1)</b>
  fizzbuzz(@Param('number') number): any {
    return this.fizzbuzzService.fizzbuzz(number);
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-272">
<ol>
<li>
<p>Nueva ruta para la kata Fizz Buzz</p>
</li>
</ol>
</div>
<div class="paragraph data-line-274">
<p>Ahora podemos probar la kata con cualuier número:</p>
</div>
<div class="ulist data-line-276">
<ul>
<li class="data-line-276">
<p><code><a href="http://localhost:3000/fizzbuzz/3" class="undefined" data-href="http://localhost:3000/fizzbuzz/3">http://localhost:3000/fizzbuzz/3</a></code> devolvería <em>Fizz</em></p>
</li>
<li class="data-line-277">
<p><code><a href="http://localhost:3000/fizzbuzz/5" class="undefined" data-href="http://localhost:3000/fizzbuzz/5">http://localhost:3000/fizzbuzz/5</a></code> devolvería <em>Buzz</em></p>
</li>
<li class="data-line-278">
<p><code><a href="http://localhost:3000/fizzbuzz/15" class="undefined" data-href="http://localhost:3000/fizzbuzz/15">http://localhost:3000/fizzbuzz/15</a></code> devolvería <em>FizzBuzz</em></p>
</li>
<li class="data-line-279">
<p><code><a href="http://localhost:3000/fizzbuzz/2" class="undefined" data-href="http://localhost:3000/fizzbuzz/2">http://localhost:3000/fizzbuzz/2</a></code> devolvería <em>2</em></p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-281">
<h3 id="_pruebas_unitarias_del_servicio">2.4. Pruebas unitarias del servicio</h3>
<div class="paragraph data-line-283">
<p>El CLI de NestJS ha creado el archivo <code>fizzbuzz/fizzbuzz.service.spec.ts</code> para los tests del servicio generado. Los tests los añadiremos en el grupo <code>describe</code> existente. Se trata de definir los casos de prueba para los casos de testing de la kata (3, 5, 15, ninguno de ellos, fuera del rango 1-100)</p>
</div>
<div class="listingblock data-line-286">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { FizzbuzzService } from './fizzbuzz.service';

describe('FizzbuzzService', () =&gt; { <b class="conum">(1)</b>
  let service: FizzbuzzService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FizzbuzzService],
    }).compile();

    service = module.get&lt;FizzbuzzService&gt;(FizzbuzzService);
  });

  it('should be defined', () =&gt; { <b class="conum">(2)</b>
    expect(service).toBeDefined();
  });

  it('should return Fizz when the number is multiple of 3', () =&gt; { <b class="conum">(3)</b>
    expect(service.fizzbuzz(3)).toBe('Fizz'); <b class="conum">(4)</b>
  });

  it('should return Buzz when the number is multiple of 5', () =&gt; {
    expect(service.fizzbuzz(5)).toBe('Buzz');
  });

  it('should return FizzBuzz when the number is multiple of 15', () =&gt; {
    expect(service.fizzbuzz(15)).toBe('FizzBuzz');
  });

  it('should return the number when then number is neither multiple of 3, 5 nor 15', () =&gt; {
    expect(service.fizzbuzz(2)).toBe(2);
  });

  it('should return nothing when the number is not between 1 and 100', () =&gt; { <b class="conum">(5)</b>
    expect(service.fizzbuzz(0)).toBe(undefined);
    expect(service.fizzbuzz(101)).toBe(undefined);
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-332">
<ol>
<li>
<p>Grupo de tests creados inicialmente por NestJS a modo de ejemplo para el servicio Fizzbuzz</p>
</li>
<li>
<p>Test inicial creado por NestJS</p>
</li>
<li>
<p>Cada test va en su función <code>it</code> (o <code>test</code>) y contiene un texto (realmente es el nombre del test) que permite entender claramente la intención del test.</p>
</li>
<li>
<p>Con <code>expect</code> indicamos lo que queremos probar y con <code>toBe</code> indicamos el valor esperado.</p>
</li>
<li>
<p>En este caso, quizá sería más apropiado crear dos tests separados para probar cada uno los de límites del rango no permitido (i.e. un test para comprobar que no se aceptan números menores que 1 y otro test para comprobar que no se aceptan números mayores que 100).</p>
</li>
</ol>
</div>
<div class="sidebarblock data-line-335">
<div class="content">
<div class="title">Estructura de un archivo de tests</div>
<div class="paragraph data-line-336">
<p>Los tests pueden hacer 3 cosas:</p>
</div>
<div class="ulist data-line-338">
<ul>
<li class="data-line-338">
<p>Preparar el entorno (setup).</p>
</li>
<li class="data-line-339">
<p>Llamar a algo (actuar) y verificar el comportamiento (assert o verificar).</p>
</li>
<li class="data-line-340">
<p>Destruir lo construido.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-342">
<p>En Jest esto lo vemos en los bloques:</p>
</div>
<div class="ulist data-line-344">
<ul>
<li class="data-line-344">
<p><code>beforeAll</code> prepara el entorno antes de ejecutar las pruebas. Se ejecuta una vez al principio de los tests.</p>
</li>
<li class="data-line-345">
<p><code>beforeEach</code> prepara el entorno antes de ejecutar cada prueba. Se ejecuta una vez antes de cada test.</p>
</li>
<li class="data-line-346">
<p><code>it</code> o <code>test</code> definen un caso de test para cada prueba. En <code>expect</code> llamamos a la operación (proceso de actuación) y con los <em>matchers</em> (<code>toBe, toEqual, toBeGreaterThan, toMatch, toContain, toThrow</code>, &#8230;&#8203;) se verifica el test. Más información en la <a href="https://jestjs.io/es-ES/docs/using-matchers" data-href="https://jestjs.io/es-ES/docs/using-matchers">página de Comparadores (matchers) de Jest</a>.</p>
</li>
<li class="data-line-347">
<p><code>afterEach</code> realiza una operación de destrucción o desmontaje del entorno después de ejecutar cada prueba. Se ejecuta una vez después de cada test.</p>
</li>
<li class="data-line-348">
<p><code>afterAll</code> destruye o desmonta el entorno tras finalizar todas las pruebas. Se ejecuta una vez al final de los tests.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph data-line-351">
<p>Para ejecutar sólo los tests del servicio y no los de todo el proyecto, lanzaremos los tests en modo <em>watch</em>:</p>
</div>
<div class="listingblock data-line-354">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:watch</code></pre>
</div>
</div>
<div class="paragraph data-line-358">
<p>Se nos indicará el modo de uso para que elijamos uno:</p>
</div>
<div class="listingblock data-line-361">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">Watch Usage
 › Press a to run all tests.
 › Press f to run only failed tests.
 › Press p to filter by a filename regex pattern. <b class="conum">(1)</b>
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.</code></pre>
</div>
</div>
<div class="colist arabic data-line-370">
<ol>
<li>
<p>Opción elegida para pasar los tests a los archivos indicados</p>
</li>
</ol>
</div>
<div class="paragraph data-line-372">
<p>Elegiremos <code>p</code> para indicar el nombre de archivo del servicio. No hace falta introducir el nombre entero. Basta con una parte del nombre que permita seleccionarlo (p.e. <code>fizzbuzz.se</code>)</p>
</div>
<div class="listingblock data-line-375">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">Pattern Mode Usage
 › Press Esc to exit pattern mode.
 › Press Enter to filter by a filenames regex pattern.

 pattern › fizzbuzz.se <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-382">
<ol>
<li>
<p>Expresión que permite seleccionar al servicio a probar</p>
</li>
</ol>
</div>
<div class="paragraph data-line-384">
<p>Y este sería el resultado del proceso de testing:</p>
</div>
<div class="listingblock data-line-387">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  src/fizzbuzz/fizzbuzz.service.spec.ts
  FizzbuzzService
    ✓ should be defined (25 ms)
    ✓ should return Fizz when the number is multiple of 3 (6 ms)
    ✓ should return Buzz when the number is multiple of 5 (4 ms)
    ✓ should return FizzBuzz when the number is multiple of 15 (21 ms)
    ✓ should return the number when then number is neither multiple of 3, 5 nor 15 (3 ms)
    ✓ should return nothing when the number is not between 1 and 100 (5 ms)

Test Suites: 1 passed, 1 total
Tests:       6 passed, 6 total
Snapshots:   0 total
Time:        2.925 s, estimated 5 s</code></pre>
</div>
</div>
<div class="sidebarblock data-line-404">
<div class="content">
<div class="title">Mostrar los datos de cada test</div>
<div class="paragraph data-line-405">
<p>De forma predeterminada, los resultados de ejecución de los tests se muestran de forma agregada si hay varias suites de tests, perdiéndose los datos de cada test individual. En ocasiones, esta información detallada de cada test puede ser útil. Para activarlo, basta con cambiar en <code>package.json</code> la entrada en <code>scripts</code> sustituyendo <code>"test": "jest",</code> por <code>"test": "jest --verbose",</code>.</p>
</div>
<div class="listingblock data-line-408">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">....
   "scripts": {
    ....
    "test": "jest --verbose", <b class="conum">(1)</b>
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
....</code></pre>
</div>
</div>
<div class="colist arabic data-line-417">
<ol>
<li>
<p>Cambio realizado para mostrar los datos de cada test.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-419">
<p>De esta forma, ahora el resultado al ejecutar <code>npm run test</code> será más detallado como se muestra a continuación:</p>
</div>
<div class="listingblock data-line-422">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript"> PASS  src/app.controller.spec.ts
  AppController
    root
      ✓ should return "Hello World!" (14 ms)

 PASS  src/fizzbuzz/fizzbuzz.controller.spec.ts
  FizzbuzzController
    ✓ should be defined (26 ms)

 PASS  src/fizzbuzz/fizzbuzz.service.spec.ts
  FizzbuzzService
    ✓ should be defined (21 ms)
    ✓ should return Fizz when the number is multiple of 3 (2 ms)
    ✓ should return Buzz when the number is multiple of 5 (2 ms)
    ✓ should return FizzBuzz when the number is multiple of 15 (2 ms)
    ✓ should return the number when then number is neither multiple of 3, 5 nor 15 (2 ms)
    ✓ should return nothing when the number is not between 1 and 100 (2 ms)

Test Suites: 3 passed, 3 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        2.575 s, estimated 3 s</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-449">
<h3 id="_cobertura_de_tests">2.5. Cobertura de tests</h3>
<div class="paragraph data-line-451">
<p>En el proceso de testing la cobertura de tests proporciona una medida muy interesante. Ofrece el porcentaje de código que está incluido en los tests, es decir, el porcentaje de código que se está probando. Esto es muy útil porque nos ayuda a dirigir los esfuerzos para crear tests para el código que aún está oculto a los tests y que puede ser una potencial fuente de errores.</p>
</div>
<div class="paragraph data-line-453">
<p>Podemos conocer la cobertura de nuestros tests con:</p>
</div>
<div class="listingblock data-line-456">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:cov</code></pre>
</div>
</div>
<div class="paragraph data-line-460">
<p>Esto ejecutará los tests nos dará el porcentaje de código testado para cada archivo y a nivel global.</p>
</div>
<div class="listingblock data-line-463">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  src/fizzbuzz/fizzbuzz.controller.spec.ts
 PASS  src/app.controller.spec.ts
 PASS  src/fizzbuzz/fizzbuzz.service.spec.ts
-------------------------|---------|----------|---------|---------|-------------------
File                     | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-------------------------|---------|----------|---------|---------|-------------------
All files                |   63.46 |      100 |   71.42 |    62.5 |
 src                     |      52 |      100 |      75 |   47.36 |
  app.controller.ts      |     100 |      100 |     100 |     100 |
  app.module.ts          |       0 |      100 |     100 |       0 | 1-11
  app.service.ts         |     100 |      100 |     100 |     100 |
  main.ts                |       0 |      100 |       0 |       0 | 1-8
 src/fizzbuzz            |   74.07 |      100 |   66.66 |   76.19 |
  fizzbuzz.controller.ts |    87.5 |      100 |      50 |   83.33 | 10
  fizzbuzz.module.ts     |       0 |      100 |     100 |       0 | 1-9
  fizzbuzz.service.ts    |     100 |      100 |     100 |     100 |
-------------------------|---------|----------|---------|---------|-------------------

Test Suites: 3 passed, 3 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        7.747 s, estimated 8 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="paragraph data-line-489">
<p>Como resultado también se genera una carpeta <code>coverage/lcov-report</code> con ese mismo informe, pero en HTML. Aparece organizado de acuerdo con los carpetas que tengamos en la carpeta <code>src</code>.</p>
</div>
<div class="imageblock data-line-491">
<div class="content">
<img src="./images/coverage100.png" alt="coverage100">
</div>
</div>
<div class="paragraph data-line-493">
<p>Si hace clic sobre <code>src/fizzbuzz</code> veremos su informe de cobertura. Vemos que está probado el 100% del código del servicio.</p>
</div>
<div class="imageblock data-line-495">
<div class="content">
<img src="./images/coverage100Fizzbuzz.png" alt="coverage100Fizzbuzz">
</div>
</div>
<div class="paragraph data-line-497">
<p>Si ahora modificamos los tests de <code>fizzbuzz/fizzbuzz.service.spec.ts</code> y comentamos uno de ellos, por ejemplo el que probaba los múltiplos de 15, y volvemos a ejecutar la cobertura de tests con <code>npm run test:cov</code>, veremos que la cobertura de <code>fizzbuzz/fizzbuzz.service.ts</code> ha bajado de 100% a 92.3%.</p>
</div>
<div class="imageblock data-line-499">
<div class="content">
<img src="./images/coverageParcial.png" alt="coverageParcial">
</div>
</div>
<div class="paragraph data-line-501">
<p>Si ahora hacemos clic sobre <code>fizzbuzz/fizzbuzz.service.ts</code> en el informe, nos llevará al archivo y nos marcará en rojo las líneas de código que no están tratadas (cubiertas) en ningún test. Como hemos comentado anteriormente, este resultado es muy importante porque nos puede guiar en el proceso de priorización de los próximos tests a desarrollar.</p>
</div>
<div class="imageblock data-line-503">
<div class="content">
<img src="./images/codigoNoProbado.png" alt="codigoNoProbado">
</div>
</div>
<div class="paragraph data-line-505">
<p>Si anulamos los comentarios del test y volvemos a ejecutar la cobertura de tests todo volverá a estar como antes y ese código ya estará de nuevo cubierto por los tests.</p>
</div>
<div class="sidebarblock data-line-508">
<div class="content">
<div class="title">¿Hace falta probarlo todo?</div>
<div class="paragraph data-line-509">
<p>En el proceso de testing decidimos qué probar. Alguien podría decir de probarlo todo con una cobertura cercana al 100%. Sin embargo, no es necesario. Sólo hay que probar las partes más críticas. Puede que esté entre el 70%-90%. Normalmente probaremos</p>
</div>
<div class="ulist data-line-511">
<ul>
<li class="data-line-511">
<p>Servicios (si hay <code>app.service.ts</code> también)</p>
</li>
<li class="data-line-512">
<p>Controladores (si hay <code>app.controller.ts</code> también)</p>
</li>
<li class="data-line-513">
<p>No hace falta probar DTOs, constantes, entidades y módulos (los podemos excluir de la cobertura -ver <a href="#_exclusión_de_archivos_de_la_cobertura_de_tests">Exclusión de archivos de la cobertura de tests</a>)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3 data-line-517">
<h4 id="_exclusión_de_archivos_de_la_cobertura_de_tests">2.5.1. Exclusión de archivos de la cobertura de tests</h4>
<div class="paragraph data-line-519">
<p>El porcentaje de cobertura de tests que devuelve el informe se obtiene teniendo en cuenta todos los archivos de código del proyecto. Sin embargo, es posible ignorar o excluir archivos del proceso de obtención de la cobertura. Esto se realiza indicando nombres de archivo o indicando un patrón en el elemento <code>coveragePathIgnorePatterns</code> del elemento <code>jest</code> en el archivo <code>package.json</code>.</p>
</div>
<div class="paragraph data-line-521">
<p>Por ejemplo, si decidimos excluir del proceso de análisis de cobertura de tests los archivos de los módulos (p.e. <code>app.module.ts</code>, <code>fizzbuzz.module.ts</code> y otros módulos), así quedaría el elemento <code>jest</code> en <code>package.json</code> para excluir los archivos de módulo:</p>
</div>
<div class="listingblock data-line-524">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "coveragePathIgnorePatterns": [".module.ts"], <b class="conum">(1)</b>
    "testEnvironment": "node"
  }</code></pre>
</div>
</div>
<div class="colist arabic data-line-544">
<ol>
<li>
<p>Ignorar del proceso de cobertura los archivos cuyo nombre termine en <code>.module.ts</code></p>
</li>
</ol>
</div>
<div class="paragraph data-line-546">
<p>Esto mejoraría el porcentaje de cobertura ya que se han retirado los archivos de módulo del proceso de cómputo de la cobertura, ya que bajaban la cobertura porque no tenían tests asociados. La figura siguiente ilustra la cobertura total. Se ha pasado de un 63.46% a un 84.61%. Esto en sí no es ni bueno ni malo, ni un objetivo en sí mismo. Es sólo estar informado que hay ciertos archivos que aceptamos no probar y que de no ser excluidos pueden estar datos erróneos de cobertura.</p>
</div>
<div class="imageblock data-line-548">
<div class="content">
<img src="./images/coverageAfterExcludingModules.png" alt="coverageAfterExcludingModules">
</div>
</div>
</div>
</div>
<div class="sect2 data-line-550">
<h3 id="_pruebas_unitarias_del_controlador">2.6. Pruebas unitarias del controlador</h3>
<div class="paragraph data-line-552">
<p>La cobertura de tests realizada en el apartado anterior nos ha servido para determinar el grado de código que tenemos testado. Hemos visto que tenemos tests para el servicio que prueban el 100% del código de sus métodos. Sin embargo, si vemos la cobertura del controlador, vemos que el código del endpoint (método <code>fizzbuzz</code>) aún está sin probar, tal y como muestra la figura siguiente.</p>
</div>
<div class="imageblock data-line-554">
<div class="content">
<img src="./images/FizzBuzzControllerSinProbar.png" alt="FizzBuzzControllerSinProbar">
</div>
</div>
<div class="paragraph data-line-556">
<p>Esto nos sugiere que debemos introducir más tests unitarios en el controlador. Para ello, y como las pruebas unitarias han de ser eso, unitarias, y ejecutarse de forma aislada, la prueba del controlador no deberá apoyarse en el método ya implementado en su servicio. Esto nos lleva a la introducción de la técnica de <em>mocking</em> para el desarrollo de pruebas unitarias. Aquí veremos cómo mockear el servicio de Fizz Buzz para que la prueba del controlador sea independiente.</p>
</div>
<div class="paragraph data-line-558">
<p>La técnica de <em>mocking</em> en un controlador básicamente va a consistir en dar una nueva implementación (el <em>mock</em>) de los servicios que usa, y usar dicha nueva implementación o <em>mock</em> para probar el controlador. Esto lo podemos llevar a cabo de dos formas: mockeando un método concreto del servicio mediante <code>jest.spyOn</code> o mockeando el servicio completo.</p>
</div>
<div class="sect3 data-line-560">
<h4 id="_mockeo_mediante_jest_spyon">2.6.1. Mockeo mediante <code>jest.spyOn</code></h4>
<div class="paragraph data-line-562">
<p><code>jest.spyOn</code> nos permite crear una nueva implementación (<em>mock</em>) sobre un método existente de un objeto. Seguiremos este patrón</p>
</div>
<div class="listingblock data-line-565">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">jest.spyOn(&lt;&lt;objeto&gt;&gt;, '&lt;&lt;metodo-existente&gt;&gt;')
    .mockImplementation(&lt;&lt;nueva-implementacion&gt;&gt;);</code></pre>
</div>
</div>
<div class="paragraph data-line-570">
<p>De esta forma, cada vez que se llame en el test al método mockeado, el método se ejecutará con la nueva implementación proporcionada en <code>mockImplementation</code>.</p>
</div>
<div class="paragraph data-line-572">
<p>A continuación mockearemos para la prueba del controlador el método <code>fizzbuzz</code> del servicio de forma que devuelva siempre <code>Fizz</code>.</p>
</div>
<div class="listingblock data-line-575">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { FizzbuzzController } from './fizzbuzz.controller';
import { FizzbuzzService } from './fizzbuzz.service';

describe('FizzbuzzController', () =&gt; {
  let controller: FizzbuzzController;
  let service: FizzbuzzService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FizzbuzzController],
      providers: [FizzbuzzService], <b class="conum">(1)</b>
    }).compile();

    controller = module.get&lt;FizzbuzzController&gt;(FizzbuzzController);
    service = module.get&lt;FizzbuzzService&gt;(FizzbuzzService); <b class="conum">(2)</b>
  });

  it('should return the correct Fizz Buzz word according the introduced number (Using spyOn)', () =&gt; { <b class="conum">(3)</b>
    const result = 'Fizz'; <b class="conum">(4)</b>

    jest.spyOn(service, 'fizzbuzz').mockImplementation(() =&gt; result); <b class="conum">(5)</b>

    expect(controller.fizzbuzz(3)).toBe(result); <b class="conum">(6)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-612">
<ol>
<li>
<p>Incorporación del servicio para poder usarlo desde el controlador</p>
</li>
<li>
<p>Creación de un objeto para el servicio</p>
</li>
<li>
<p>Declaración del test</p>
</li>
<li>
<p>Configuración del valor que esperamos</p>
</li>
<li>
<p>Mockear el método <code>fizzbuzz</code> del servicio creado para que siempre devuelva lo configurado en <code>result</code></p>
</li>
<li>
<p>Ejecutar el método <code>fizzbuzz</code> del controlador y comprobar que el resultado es correcto</p>
</li>
</ol>
</div>
<div class="paragraph data-line-614">
<p>Como el método <code>fizzbuzz</code> ahora está mockeado en el test, la implementación que se usará es la propocionada. En este caso, siempre devuelve lo que hemos configurado en <code>result</code> (<code>Fizz</code> para este ejemplo).</p>
</div>
<div class="paragraph data-line-616">
<p>A continuación se muestra el resultado de pasar los tests al controlador con <code>npm run test:watch</code> y pasándole <code>fizzbuzz.co</code> como patrón de archivo.</p>
</div>
<div class="listingblock data-line-619">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  src/fizzbuzz/fizzbuzz.controller.spec.ts
  FizzbuzzController
    ✓ should return the correct Fizz Buzz word according the introduced number (Using spyOn) (14 ms) <b class="conum">(1)</b>
    ✓ should be defined (3 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        4.621 s
Ran all test suites matching /fizzbuzz.co/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="colist arabic data-line-633">
<ol>
<li>
<p>Test pasado con éxito</p>
</li>
</ol>
</div>
<div class="admonitionblock note data-line-636">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-637">
<p>Con el testing unitario del controlador se trata de probar si los métodos del controlador tienen algún tipo de error. Damos por hecho que el servicio funciona correctamente. Y la opción de hacer la prueba como una petición <code>GET HTTP</code> no procede porque cae en el ámbito de las <a href="#_pruebas_de_integración">Pruebas de integración</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 data-line-640">
<h4 id="_mockeado_del_servicio_completo">2.6.2. Mockeado del servicio completo</h4>
<div class="paragraph data-line-642">
<p>Otra alternativa al mockeado de un método concreto de un servicio es el mockeado del servicio completo. Se trata entonces de mockear todos los métodos del servicio. Podremos hacerlo mockeando el servicio en la misma clase en la que se va a usar, o bien, mockearlo en una clase aparte, lo que permitirá su reutilización. Por sencillez, aquí lo mockearemos in situ y no en una clase aparte.</p>
</div>
<div class="paragraph data-line-644">
<p>La forma de proceder se podría resumir así:</p>
</div>
<div class="olist arabic data-line-646">
<ol class="arabic">
<li class="data-line-646">
<p>Crear un objeto para el mock del servicio y que dicho objeto contenga la nueva implementación de cada uno de sus métodos. El mockeo se realizará mediante un objeto JSON formado por pares <em>método-valor devuelto</em>.</p>
</li>
<li class="data-line-647">
<p>Sustituir el servicio en la definición del módulo del test (normalmente en el <code>Test.createTestingModule</code> dentro del <code>beforeEach</code>) por el servicio mockeado.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-649">
<p>Veamos cómo hacerlo.</p>
</div>
<div class="listingblock data-line-652">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { FizzbuzzController } from './fizzbuzz.controller';
import { FizzbuzzService } from './fizzbuzz.service';

describe('FizzbuzzController', () =&gt; {
  let controller: FizzbuzzController;
  let service: FizzbuzzService;

  let mockedFizzBuzzValue = 'Buzz'; <b class="conum">(1)</b>
  let mockFizzBuzzService = { <b class="conum">(2)</b>
    fizzbuzz: () =&gt; mockedFizzBuzzValue, <b class="conum">(3)</b>
  };

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FizzbuzzController],
      providers: [FizzbuzzService],
    })
      .overrideProvider(FizzbuzzService) <b class="conum">(4)</b>
      .useValue(mockFizzBuzzService) <b class="conum">(5)</b>
      .compile();

    controller = module.get&lt;FizzbuzzController&gt;(FizzbuzzController);
    service = module.get&lt;FizzbuzzService&gt;(FizzbuzzService);
  });

  it('should return the correct Fizz Buzz word according the introduced number (Using spyOn)', () =&gt; {
    const result = 'Fizz';

    const fizzbuzzSpy = jest.spyOn(service, 'fizzbuzz');
    fizzbuzzSpy.mockImplementation(() =&gt; result);

    expect(controller.fizzbuzz(3)).toBe(result);

    fizzbuzzSpy.mockRestore();
  });

  it('should return the correct Fizz Buzz word according the introduced number (Using mocking de servicios)', () =&gt; { <b class="conum">(6)</b>
    expect(controller.fizzbuzz(5)).toBe(mockedFizzBuzzValue); <b class="conum">(7)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-705">
<ol>
<li>
<p>Configuración del valor devuelto por el servicio mockeado</p>
</li>
<li>
<p>Objeto que va a representar al servicio mockeado</p>
</li>
<li>
<p>Mock del método <code>fizzbuzz</code> y su respuesta mockeada. Es un par <em>método-valor devuelto</em></p>
</li>
<li>
<p>Servicio a mockear</p>
</li>
<li>
<p>Reemplazar el servicio por el objeto que tiene el mock del servicio</p>
</li>
<li>
<p>Definición del caso de prueba</p>
</li>
<li>
<p>Lanzar el método <code>fizzbuzz</code> del controlador y comprobar que devuelve el valor mockeado</p>
</li>
</ol>
</div>
<div class="paragraph data-line-707">
<p>Al igual que antes, cuando el controlador llama a su método <code>fizzbuzz</code>, éste llama al método del servicio, pero el controlador no sabe que el método está mockeado. Un engaño en toda regla.</p>
</div>
<div class="imageblock data-line-709">
<div class="content">
<img src="./images/trileros.jpg" alt="trileros">
</div>
</div>
<div class="paragraph data-line-711">
<p>Por tanto, con esta implementación, cada vez que se llame al método <code>fizzbuzz</code> éste devolverá la respuesta mockeada (<code>Buzz</code>) en este caso. Con esto habremos comprobado el funcionamiento del controlador en sí y de forma independiente del servicio. Sólo hacemos la prueba con un valor del servicio puesto que la validez del servicio con distintos valores cae en el ámbito de las pruebas unitarias del servicio, no en las del controlador.</p>
</div>
<div class="admonitionblock note data-line-714">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-715">
<p>En nuestro caso no vamos a notar la diferencia entre el mockeo con <code>jest.spyOn</code> y el mockeo del servicio completo porque el servicio de Fizz Buzz cuenta sólo con un método. En servicios con más métodos, el mockeo del servicio completo exige mockear todos los métodos, mientras que el mockeo con `jest.spyOn_ permite ser mñás finos y mockear un sólo método y dejar el resto del servicio inalterado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-718">
<p>Tras los cambios, se vuelven a pasar los tests y este es su resultado:</p>
</div>
<div class="listingblock data-line-721">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  src/fizzbuzz/fizzbuzz.controller.spec.ts
  FizzbuzzController
    ✓ should return the correct Fizz Buzz word according the introduced number (Using spyOn) (14 ms)
    ✓ should return the correct Fizz Buzz word according the introduced number (Using mocking de servicios) (3 ms) <b class="conum">(1)</b>
    ✓ should be defined (3 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        3.202 s, estimated 5 s
Ran all test suites matching /fizzbuzz.co/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="colist arabic data-line-736">
<ol>
<li>
<p>Test con el servicio mockeado al completo</p>
</li>
</ol>
</div>
<div class="paragraph data-line-738">
<p>El test con <code>jest.spyOn</code> sigue funcionando porque recordemos que él tiene su propia implementación del mock del método, independientemente de que se haya mockeado el servicio por completo.</p>
</div>
<div class="paragraph data-line-740">
<p>Para finalizar, si ahora volvemos a hacer la cobertura de tests, el controlador ya aparece testado y la cobertura habrá subido. Las figuras siguientes lo ilustran.</p>
</div>
<div class="imageblock data-line-742">
<div class="content">
<img src="./images/ContollerCoverageTesting100.png" alt="ContollerCoverageTesting100">
</div>
</div>
<div class="imageblock data-line-744">
<div class="content">
<img src="./images/FullCoverageOnController.png" alt="FullCoverageOnController">
</div>
</div>
</div>
</div>
<div class="sect2 data-line-747">
<h3 id="_pruebas_de_integración">2.7. Pruebas de integración</h3>
<div class="paragraph data-line-749">
<p>En las pruebas unitarias comprobamos que partes pequeñas y aisladas del software funcionan según lo esperado. Se encargan de probar unidades sin dependencias o bien mockeando las dependencias para llevar a cabo los tests.</p>
</div>
<div class="paragraph data-line-751">
<p>Sin embargo, las pruebas de integración verifican que varias unidades funcionan correctamente de forma conjunta (p.e. controladores con servicios). Las pruebas de integración prueban su comportamiento de forma conjunta y tratan de reducir al máximo el uso de mocks.</p>
</div>
<div class="paragraph data-line-753">
<p>Veamos el caso de prueba de integración que genera el CLI de NestJS al crear el proyecto (<code>tests/app.e2e-spec.ts</code>).</p>
</div>
<div class="listingblock data-line-756">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () =&gt; { <b class="conum">(1)</b>
  let app: INestApplication;

  beforeEach(async () =&gt; { <b class="conum">(2)</b>
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () =&gt; { <b class="conum">(3)</b>
    return request(app.getHttpServer()) <b class="conum">(4)</b>
      .get('/') <b class="conum">(5)</b>
      .expect(200) <b class="conum">(6)</b>
      .expect('Hello World!'); <b class="conum">(7)</b>
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-788">
<ol>
<li>
<p>Bloque de tests</p>
</li>
<li>
<p>Función de preparación del entorno de cada test creando de nuevo la aplicación</p>
</li>
<li>
<p>Test de un endpoint</p>
</li>
<li>
<p>Realización de llamada a la API</p>
</li>
<li>
<p>Ir a la ruta indicada</p>
</li>
<li>
<p>Código de estado HTTP esperado</p>
</li>
<li>
<p>Valor esperado</p>
</li>
</ol>
</div>
<div class="paragraph data-line-790">
<p>Ejecutamos los tests con</p>
</div>
<div class="listingblock data-line-793">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:e2e</code></pre>
</div>
</div>
<div class="paragraph data-line-797">
<p>Esto pasará los tests y devolverá lo siguiente:</p>
</div>
<div class="listingblock data-line-799">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">PASS  test/app.e2e-spec.ts
  AppController (e2e)
    ✓ / (GET) (392 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.438 s, estimated 3 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="paragraph data-line-811">
<p>Este test ha atacado directamente a la API a través del controlador de Fizz Buzz. Este ha usado el servicio y ha devuelto la respuesta a la petición realizada. Es decir, han intervenido tanto la aplicación, como el controlador de Fizz Buzz, como su servicio. Por eso es que recibe el nombre de prueba de integración, porque combina/integra a varias partes de la aplicación en un solo test.</p>
</div>
<div class="admonitionblock note data-line-814">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-815">
<p>NestJS usa Supertest para simular las llamadas HTTP.</p>
</div>
<div class="paragraph data-line-817">
<p>En el archivo <code>tests/jest-e2e.json</code> se definen las opciones de Jest para las pruebas de integración.</p>
</div>
<div class="listingblock data-line-820">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$", <b class="conum">(1)</b>
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-831">
<ol>
<li>
<p><code>testRegex</code> define una expresión regular para indicar los archivos que se considerarán sujetos a las pruebas de integración.</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-834">
<p>Una vez visto el ejemplo de base, veamos cómo hacer las pruebas del endpoint de la API de Fizz Buzz. Con esto automatizaremos la prueba de cada endpoint de la API. Para probarlo sobre Fizz Buzz, lo haremos creando un archivo <code>test/fizzbuzz.e2e-spec.ts</code> para los tests de integración de llamada al endpoint con los diferentes valores. Crearemos este archivo copiándolo desde <code>test/app.e2e-spec.ts</code> introduciendo los cambios siguientes:</p>
</div>
<div class="paragraph data-line-836">
<p>Archivo <code>test/app.e2e-spec.ts</code></p>
</div>
<div class="listingblock data-line-838">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('FizzBuzz (e2e)', () =&gt; { <b class="conum">(1)</b>
  let app: INestApplication;

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/fizzbuzz/3 (GET) should return Fizz', () =&gt; { <b class="conum">(2)</b>
    return request(app.getHttpServer()) <b class="conum">(3)</b>
      .get('/fizzbuzz/3') <b class="conum">(4)</b>
      .expect(200) <b class="conum">(5)</b>
      .expect('Fizz'); <b class="conum">(6)</b>
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-870">
<ol>
<li>
<p>Cambiamos la descripción del bloque <code>describe</code></p>
</li>
<li>
<p>Caso de prueba de llamada al endpoint</p>
</li>
<li>
<p>Creación de un objeto HTTP para hacer las peticiones</p>
</li>
<li>
<p>Acceso a la ruta del endpoint</p>
</li>
<li>
<p>Código de estado HTTP esperado</p>
</li>
<li>
<p>Respuesta esperada</p>
</li>
</ol>
</div>
<div class="admonitionblock note data-line-873">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-874">
<p>Si tuviéramos más endpoints crearíamos más funciones <code>it</code>, una para cada endopoint.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-877">
<p>Si ahora volvemos a pasar los tests con <code>npm run test:e2e</code> vemos que se pasan las pruebas de <code>app</code> y de <code>fizzbuzz</code>, pero el resultado se muestra agregado y no incluye el resultado de cada uno de los casos de prueba</p>
</div>
<div class="listingblock data-line-880">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/app.e2e-spec.ts
 PASS  test/fizzbuzz.e2e-spec.ts

Test Suites: 2 passed, 2 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        4.325 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="paragraph data-line-891">
<p>Si queremos ver el resultado de cada uno de los casos de prueba dentro de cada suite, haremos el cambio siguiente sobre la configuración de Jest en el archivo <code>package.json</code> incluyendo la opción de <code>--verbose</code> en los tests de integración.</p>
</div>
<div class="listingblock data-line-894">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">...
  "scripts": {
    ...
    "test:e2e": "jest --config ./test/jest-e2e.json --verbose" <b class="conum">(1)</b>
  },
...
&lt;1&gt; Incluimos la opción `--verbose` para que muestre los resultados individuales de los tests.</code></pre>
</div>
</div>
<div class="paragraph data-line-904">
<p>Si ahora volvemos a ejecutar los tests de integración con <code>npm run test:e2e</code> vemos que ya sí aparecen los tests de cada suite.</p>
</div>
<div class="listingblock data-line-907">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  test/fizzbuzz.e2e-spec.ts
  FizzBuzz (e2e)
    ✓ /fizzbuzz/3 (GET) should return Fizz (380 ms) <b class="conum">(1)</b>

 PASS  test/app.e2e-spec.ts
  AppController (e2e)
    ✓ / (GET) (377 ms) <b class="conum">(2)</b>

Test Suites: 2 passed, 2 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        2.663 s, estimated 4 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="colist arabic data-line-923">
<ol>
<li>
<p>Test de integración de FizzBuzz</p>
</li>
<li>
<p>Test de integración de app</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-925">
<h2 id="_caso_de_uso_reserva_de_espacios">3. Caso de uso. Reserva de espacios</h2>
<div class="sectionbody">
<div class="paragraph data-line-927">
<p>Para ilustrar en este tutorial los tests unitarios y de integración sobre una API REST que interactúe con una bases de datos, así como el testing de controladores, servicios y uso de mocks, vamos a desarrollar un caso de uso sobre una API de solicitud de espacios. La API ofrecerá los endpoints para las operaciones básicas de crear una solicitud, obtener el listado de solicitudes, obtener una solicitud a partir de su id, modificar y eliminar una solicitud.</p>
</div>
<div class="paragraph data-line-929">
<p>Para no complicar demasiado el ejemplo pero que también dé juego, de cada solicitud se guarda:</p>
</div>
<div class="ulist data-line-931">
<ul>
<li class="data-line-931">
<p><code>id</code>: numérico</p>
</li>
<li class="data-line-932">
<p><code>nombre</code>: cadena</p>
</li>
<li class="data-line-933">
<p><code>cargo</code>: cadena</p>
</li>
<li class="data-line-934">
<p><code>unidad</code>: cadena</p>
</li>
<li class="data-line-935">
<p><code>telefono</code>: cadena</p>
</li>
<li class="data-line-936">
<p><code>email</code>: cadena</p>
</li>
<li class="data-line-937">
<p><code>tipo</code>: cadena</p>
</li>
<li class="data-line-938">
<p><code>nombreActividad</code>: cadena</p>
</li>
<li class="data-line-939">
<p><code>start</code>: fecha</p>
</li>
<li class="data-line-940">
<p><code>end</code>: fecha</p>
</li>
<li class="data-line-941">
<p><code>dia</code>: cadena (día de la semana)</p>
</li>
<li class="data-line-942">
<p><code>horaInicio</code>: numérico (sólo guardaremos las horas sin los minutos)</p>
</li>
<li class="data-line-943">
<p><code>horaFin</code>: numérico (sólo guardaremos las horas sin los minutos)</p>
</li>
</ul>
</div>
<div class="paragraph data-line-945">
<p>Partimos de un <a href="https://github.com/ualmtorres/nestjs-espacios/tree/base" data-href="https://github.com/ualmtorres/nestjs-espacios/tree/base">repositorio base</a> disponible en GitHub (rama <code>base</code>) con el código incial de base para poder seguir este tutorial. Para más información sobre cómo crear y configurar el proyecto de este caso de uso consultar el <a href="#_anexo_ii_configuración_inicial_del_proyecto">Anexo II. Configuración inicial del proyecto</a></p>
</div>
<div class="paragraph data-line-947">
<p>El proyecto clonado ya tiene definidos los controladores, servicios, DTOs, entidades así como los archivos de testing .</p>
</div>
<div class="admonitionblock note data-line-949">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-950">
<p>Para clonar la rama <code>base</code>, clonar el repositorio con este comando</p>
</div>
<div class="listingblock data-line-953">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ git clone -b base https://github.com/ualmtorres/nestjs-espacios/tree/base</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-958">
<p>El proyecto utiliza SQLite como base de datos, incorpora autenticación JWT para los endpoints y usa Swagger OpenAPI. Tiene la estructura siguiente.</p>
</div>
<div class="listingblock data-line-961">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">├── LICENSE.md
├── README.md
├── dev.sqlite
├── nest-cli.json
├── package-lock.json
├── package.json <b class="conum">(1)</b>
├── src
│   ├── app.controller.spec.ts <b class="conum">(2)</b>
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   ├── auth <b class="conum">(3)</b>
│   │   ├── auth.module.ts
│   │   └── jwt.strategy.ts
│   ├── config <b class="conum">(4)</b>
│   │   ├── configuration.ts
│   │   └── database-config.service.ts
│   ├── espacio <b class="conum">(5)</b>
│   │   ├── dto
│   │   │   ├── create-espacio.dto.ts
│   │   │   └── update-espacio.dto.ts
│   │   ├── entities
│   │   │   └── espacio.entity.ts
│   │   ├── espacio.controller.spec.ts <b class="conum">(6)</b>
│   │   ├── espacio.controller.ts
│   │   ├── espacio.module.ts
│   │   ├── espacio.service.spec.ts <b class="conum">(7)</b>
│   │   ├── espacio.service.ts
│   │   └── ponicode
│   ├── main.ts
│   ├── reserva <b class="conum">(8)</b>
│   │   ├── dto
│   │   │   ├── create-reserva.dto.ts
│   │   │   └── update-reserva.dto.ts
│   │   ├── entities
│   │   │   └── reserva.entity.ts
│   │   ├── reserva.controller.spec.ts <b class="conum">(9)</b>
│   │   ├── reserva.controller.ts
│   │   ├── reserva.module.ts
│   │   ├── reserva.service.spec.ts <b class="conum">(10)</b>
│   │   └── reserva.service.ts
│   └── solicitud <b class="conum">(11)</b>
│       ├── dto
│       │   ├── create-solicitud.dto.ts
│       │   └── update-solicitud.dto.ts
│       ├── entities
│       │   └── solicitud.entity.ts
│       ├── solicitud.controller.spec.ts <b class="conum">(12)</b>
│       ├── solicitud.controller.ts
│       ├── solicitud.module.ts
│       ├── solicitud.service.spec.ts <b class="conum">(13)</b>
│       └── solicitud.service.ts
├── test <b class="conum">(14)</b>
│   ├── app.e2e-spec.ts  <b class="conum">(15)</b>
│   └── jest-e2e.json <b class="conum">(16)</b>
├── tsconfig.build.json
└── tsconfig.json</code></pre>
</div>
</div>
<div class="colist arabic data-line-1035">
<ol>
<li>
<p>Aquí se realiza la configuración de Jest</p>
</li>
<li>
<p>Archivo de pruebas de <code>app.controller</code></p>
</li>
<li>
<p>Carpeta de configuración del módulo de autenticación JWT</p>
</li>
<li>
<p>Carpeta de configuración de la aplicación y de la base de datos</p>
</li>
<li>
<p>Carpeta de los objetos relativos a los espacios</p>
</li>
<li>
<p>Archivo de pruebas del controlador de espacios</p>
</li>
<li>
<p>Archivo de pruebas del servicio de espacios</p>
</li>
<li>
<p>Carpeta de los objetos relativos a las reservas</p>
</li>
<li>
<p>Archivo de pruebas del controlador de reservas</p>
</li>
<li>
<p>Archivo de pruebas del servicio de reservas</p>
</li>
<li>
<p>Carpeta de los objetos relativos a las solicitudes</p>
</li>
<li>
<p>Archivo de pruebas del controlador de solicitudes</p>
</li>
<li>
<p>Archivo de pruebas del servicio de solicitudes</p>
</li>
<li>
<p>Carpeta de configuración de los tests de integración</p>
</li>
<li>
<p>Archivo de test de integración inicial generado por el CLI de Nest</p>
</li>
<li>
<p>Archivo de connfiguración de Jest para los tests de integración</p>
</li>
</ol>
</div>
<div class="sect2 data-line-1037">
<h3 id="_primeros_tests">3.1. Primeros tests</h3>
<div class="paragraph data-line-1040">
<p>Comenzamos lanzando los tests sobre el proyecto creado con el comando siguiente</p>
</div>
<div class="listingblock data-line-1043">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test</code></pre>
</div>
</div>
<div class="paragraph data-line-1047">
<p>Tras unos instantes comprobamos que se han ejecutado 7 suites de tests, pero sólo una se ha ejecutado con éxito, la de <code>src/app.controller.spec.ts</code>. Sin embargo, ningún test de controlador:</p>
</div>
<div class="ulist data-line-1049">
<ul>
<li class="data-line-1049">
<p><code>solicitud.controller.spec.ts</code></p>
</li>
<li class="data-line-1050">
<p><code>espacio.controller.spec.ts</code></p>
</li>
<li class="data-line-1051">
<p><code>reserva.controller.spec.ts</code></p>
</li>
</ul>
</div>
<div class="paragraph data-line-1053">
<p>ni de servicio:</p>
</div>
<div class="ulist data-line-1055">
<ul>
<li class="data-line-1055">
<p><code>solicitud.service.spec.ts</code></p>
</li>
<li class="data-line-1056">
<p><code>espacio.service.spec.ts</code></p>
</li>
<li class="data-line-1057">
<p><code>reserva.service.spec.ts</code></p>
</li>
</ul>
</div>
<div class="paragraph data-line-1059">
<p>ha tenido éxito. En todos los casos nos indica que no está definido su <em>provider</em>.</p>
</div>
<div class="paragraph data-line-1061">
<p>A continuación veremos cómo resolver estos problemas y lo haremos desde el controlador hacia adentro. Es decir, primero haremos los tests unitarios del controlador y después los tests unitarios del servicio. Explicaremos este proceso sobre las solicitudes, dejando la parte de espacios y reservas para mostrar únicamente los tests, pero ya sin explicaciones, ya que serán análogas a las descritas para solicitudes.</p>
</div>
<div class="paragraph data-line-1063">
<p>Finalmente, dedicaremos una sección a realizar los tests de integración.</p>
</div>
</div>
<div class="sect2 data-line-1065">
<h3 id="_tests_del_controlador_de_solicitudes">3.2. Tests del controlador de solicitudes</h3>
<div class="paragraph data-line-1067">
<p>Los tests del controlador fallan porque mientras que en el arranque de la aplicación se cargan los módulos correctamente, al ejecutar los tests se utilizan módulos diferentes de los del entorno de ejecución/desarrollo. Y lo importante, <strong>en el entorno de testing inicialmente esos módulos no pueden resolver sus dependencias</strong>. Concretamente, lo que está ocurriendo es que el controlador no puede resolver en el entorno de pruebas su dependencia de <code>SolicitudService</code></p>
</div>
<div class="paragraph data-line-1069">
<p>Extracto del archivo <code>solicitud/solicitud.controller.ts</code>:</p>
</div>
<div class="listingblock data-line-1071">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Controller('solicitud')
...
export class SolicitudController {
  constructor(private readonly solicitudService: SolicitudService) {}
 <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1080">
<ol>
<li>
<p>Dependencia del controlador respecto a <code>SolicitudService</code></p>
</li>
</ol>
</div>
<div class="paragraph data-line-1082">
<p>En el código siguiente del test del controlador, generado por el CLI de NestJS al generar el controlador, vemos que dentro de <code>beforeEach</code> se usa la clase <code>Test</code> y un método <code>createTestingModule</code>. Este método toma los mismos argumentos que se usan para crear un módulo (p.e. <code>imports</code>, <code>providers</code>, <code>controllers</code> &#8230;&#8203;). Tras definir el nuevo módulo (el de testing) y llamar al método <code>compile</code> se crea el módulo para testing con sus dependencias similar a los módulos creados para el entorno de ejecución.</p>
</div>
<div class="paragraph data-line-1084">
<p>Archivo <code>src/solicitud/solicitud.controller.spec.ts</code></p>
</div>
<div class="listingblock data-line-1086">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudController } from './solicitud.controller';
import { SolicitudService } from './solicitud.service';

describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({ <b class="conum">(1)</b>
      controllers: [SolicitudController],
      providers: [SolicitudService], <b class="conum">(2)</b>
    }).compile();

    controller = module.get&lt;SolicitudController&gt;(SolicitudController); <b class="conum">(3)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-1110">
<ol>
<li>
<p>Definición del módulo para el testing del controlador</p>
</li>
<li>
<p>Servicio a utilizar</p>
</li>
<li>
<p>Creación de una instancia del controller</p>
</li>
</ol>
</div>
<div class="sect3 data-line-1112">
<h4 id="_primer_paso_evitar_que_falle_el_test">3.2.1. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-1114">
<p>Seguiremos un enfoque progresivo para conseguir que nuestros tests funcionen. Se trata de ayudar a que en primer lugar desaparezcan los errores de las pruebas del controlador. Posteriormente, se irán refinando los tests.</p>
</div>
<div class="paragraph data-line-1116">
<p>El test del controlador falla porque el controlador no es capaz de resolver sus dependencias. Lo que haremos es sustituir el servicio original por un servicio de uso exclusivo en testing. Con esto, conseguiremos probar únicamente el controlador, aislándolo del servicio, que es la premisa de los tests unitarios: probar sólo una cosa en cada test.</p>
</div>
<div class="paragraph data-line-1118">
<p>Pasos:</p>
</div>
<div class="olist arabic data-line-1120">
<ol class="arabic">
<li class="data-line-1120">
<p>Crearemos un objeto <code>mockSolicitudService</code> que sustituya (<em>mockee</em>) al servicio. Inicialmente <code>mockSolicitudService</code> estará vacío. Posteriormente le iremos añadiendo los métodos falseados (<em>mockeados</em>).</p>
</li>
<li class="data-line-1121">
<p>Construir un módulo de testing que reemplace el servicio original de la solicitud por el mockeado que hemos creado en el paso anterior.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-1124">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudController } from './solicitud.controller';
import { SolicitudService } from './solicitud.service';

describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let mockSolicitudService = {}; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SolicitudController],
      providers: [SolicitudService],
    })
      .overrideProvider(SolicitudService) <b class="conum">(2)</b>
      .useValue(mockSolicitudService) <b class="conum">(3)</b>
      .compile(); <b class="conum">(4)</b>

    controller = module.get&lt;SolicitudController&gt;(SolicitudController);
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-1154">
<ol>
<li>
<p>Mock del servicio. Inicialmente vacío para pasar el test</p>
</li>
<li>
<p>Servicio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Servicio que sustituye (mockea) al original. Usamos el creado en paso 1.</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1156">
<p>Lanzaremos ahora los tests unitarios, pero no los lanzaremos todos como hacíamos antes al ejecutar <code>npm run test</code>. En este proceso paulatino de creación de los tests unitarios nos ceñiremos sólo a los tests del controlador y además lo haremos en modo <code>watch</code>. Así, cada vez que hagamos cambios sobre el código se volverán a ejecutar los tests.</p>
</div>
<div class="listingblock data-line-1159">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ npm run test:watch

Watch Usage
 › Press a to run all tests.
 › Press f to run only failed tests.
 › Press p to filter by a filename regex pattern. <b class="conum">(1)</b>
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.</code></pre>
</div>
</div>
<div class="colist arabic data-line-1170">
<ol>
<li>
<p>Para ejecutar los tests de los nombres de archivo de acuerdo a una expresión regular</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1172">
<p>Pulsaremos <code>p</code> para indicar que sólo se pasen los tests a los archivos que sigan un patrón concreto de nombre de archivo. Introduciremos <code>solicitud.co</code> como patrón. Con esto, se pasarán los tests sólo al controlador de la solicitudes y obtendremos un resultado como el siguiente:</p>
</div>
<div class="listingblock data-line-1175">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/solicitud/solicitud.controller.spec.ts
  SolicitudController
    ✓ should be defined (13 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        3.714 s, estimated 4 s
Ran all test suites matching /solicitud.co/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="paragraph data-line-1189">
<p>Objetivo cumplido!! Hemos conseguido hacer que desaparezca el error al ejecutar el test del controlador. A continuación, comenzaremos a añadirle tests.</p>
</div>
</div>
<div class="sect3 data-line-1191">
<h4 id="_segundo_paso_añadir_tests">3.2.2. Segundo paso. Añadir tests</h4>
<div class="paragraph data-line-1193">
<p>Una vez que hemos configurado el módulo para que el test no falle mediante el mockeo del servicio, vamos a ir creando tests del controlador. Comenzaremos por el de creación de solicitudes añadiendo el test siguiente después del test <code>should be defined</code>. Con este nuevo test definimos un nuevo DTO para crear una solicitud y esperamos que nos devuelva un objeto con un <code>id</code> (da igual el que sea. En el código de producción sería el <code>id</code> que generaría la base de datos) y el resto de campos coincidirán con los del DTO de creación de solicitudes.</p>
</div>
<div class="paragraph data-line-1195">
<p>Archivo <code>src/solicitud/solicitud.controller.spec.ts</code></p>
</div>
<div class="listingblock data-line-1197">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should create a solicitud', () =&gt; {
    const createSolicitudDto: CreateSolicitudDto = { <b class="conum">(1)</b>
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };

    expect(controller.create(createSolicitudDto)).toEqual({ <b class="conum">(2)</b>
      id: expect.any(Number),
      ...createSolicitudDto,
    });
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1223">
<ol>
<li>
<p>DTO de la solicitud a crear</p>
</li>
<li>
<p>Probamos que la solicitud creada consiste en un <code>id</code> junto a los datos proporcionados en el DTO para crear la solicitud</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1225">
<p>Tras guardar los cambios, como estamos en modo <code>watch</code> se volverán a pasar los tests y nos da un fallo: el método <code>create</code> no existe en el mock del servicio, tal y como se muestra a continuación:</p>
</div>
<div class="listingblock data-line-1228">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts"> FAIL  src/solicitud/solicitud.controller.spec.ts <b class="conum">(1)</b>
  SolicitudController
    ✓ should be defined (13 ms)
    ✕ should create a solicitud (5 ms)

  ● SolicitudController › should create a solicitud

    TypeError: this.solicitudService.create is not a function <b class="conum">(2)</b>

      25 |   @Post()
      26 |   create(@Body() createSolicitudDto: CreateSolicitudDto): Promise&lt;Solicitud&gt; {
    &gt; 27 |     return this.solicitudService.create(createSolicitudDto); <b class="conum">(3)</b>
         |                                  ^
      28 |   }
      29 |
      30 |   @Get()

      at SolicitudController.create (solicitud/solicitud.controller.ts:27:34)
      at Object.&lt;anonymous&gt; (solicitud/solicitud.controller.spec.ts:42:23)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        3.907 s, estimated 5 s
Ran all test suites matching /solicitud.co/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="colist arabic data-line-1259">
<ol>
<li>
<p>El test no pasa</p>
</li>
<li>
<p>El método <code>create</code> no existe en el mock del servicio (recordamos que estamos en el mockeado)</p>
</li>
<li>
<p>Línea en la que se provoca el error en el test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1261">
<p>El error se debe a que en la sección anterior creamos el mock del servicio de la solicitud, pero lo creamos vacío, sin ningún método, tal y como se muestra a continuación.</p>
</div>
<div class="listingblock data-line-1264">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let mockSolicitudService = {}; <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1271">
<ol>
<li>
<p>Mock del servicio creado vacío inicialmente</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1273">
<p>A continuación crearemos la implementación que mockea al método <code>create</code> del servicio. Se limitará a tomar un DTO y devolver un objeto con un <code>id</code> aleatorio (simulando lo que haría la base de datos) y el DTO.</p>
</div>
<div class="paragraph data-line-1275">
<p>Archivo <code>src/solicitud/solicitud.controller.spec.ts</code></p>
</div>
<div class="listingblock data-line-1277">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let mockSolicitudService = {
    create: jest.fn((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
        ...dto, <b class="conum">(3)</b>
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1293">
<ol>
<li>
<p>Método <code>create</code> mockeado.</p>
</li>
<li>
<p>id aleatorio</p>
</li>
<li>
<p>Incorporar el DTO del objeto a crear</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1295">
<p>Una vez realizados estos cambios, el test de crear una solicitud pasa correctamente.</p>
</div>
<div class="listingblock data-line-1298">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/solicitud/solicitud.controller.spec.ts
  SolicitudController
    ✓ should be defined (13 ms)
    ✓ should create a solicitud (4 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        3.941 s, estimated 4 s
Ran all test suites matching /solicitud.co/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="sidebarblock data-line-1314">
<div class="content">
<div class="title">Funciones de mock con <code>jest.fn()</code></div>
<div class="paragraph data-line-1315">
<p>Las funciones de mock se usan para inyectar o falsear código durante los tests.
<code>jest.fn()</code> crea una función de mock y opcionalmente puede tomar una implementación como parámetro.</p>
</div>
<div class="paragraph data-line-1318">
<p>Las funciones de mock tienen la propiedad <code>mock</code> que permite, entre otros, conocer los argumentos con los que fue llamada, obtener la cantidad de veces que fue llamada, y ver el valor de los argumentos en una llamada concreta, por ejemplo, en la tercera vez que fue llamada.</p>
</div>
<div class="paragraph data-line-1320">
<p>También tiene métodos interesantes como los siguientes:</p>
</div>
<div class="ulist data-line-1322">
<ul>
<li class="data-line-1322">
<p><code>mockReturnValue()</code>: Devuelve el valor que se pase como argumento</p>
</li>
<li class="data-line-1323">
<p><code>mockResolvedValue()</code>: Devuelve el valor resuelto por una promesa</p>
</li>
<li class="data-line-1324">
<p><code>mockImplementation()</code>: Acepta una función que es usada como implementación del mock</p>
</li>
<li class="data-line-1325">
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph data-line-1328">
<p>A continuación añadiremos otro test. Por ejemplo, añadiremos el test para actualizar una solicitud. Comenzaremos creando el test en <code>src/solicitud/solicitud.controller.spec.ts</code>. Lo añadiremos a continuación de los otros tests definidos.</p>
</div>
<div class="listingblock data-line-1331">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should update a solicitud', () =&gt; {
    const updateSolicitudDto: UpdateSolicitudDto = { <b class="conum">(1)</b>
      nombre: 'John Smith', <b class="conum">(2)</b>
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 2; <b class="conum">(3)</b>

    expect(controller.update(solicitudId, updateSolicitudDto)).toEqual(
      {
        id: solicitudId,
        ...updateSolicitudDto,
      },
    );
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1362">
<ol>
<li>
<p>DTO con los cambios de la solicitud</p>
</li>
<li>
<p>Nombre modificado</p>
</li>
<li>
<p><code>id</code> de la solicitud a modificar</p>
</li>
<li>
<p>Se espera que resultado de actualizar la solicitud sea la solicitud  con el <code>id</code> y los datos actualizados.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1364">
<p>Tras guardar los cambios se volverán a pasar los tests y no pasará este test porque no está definido el método <code>update</code> en el mock del servicio.</p>
</div>
<div class="listingblock data-line-1367">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  src/solicitud/solicitud.controller.spec.ts <b class="conum">(1)</b>
  SolicitudController
    ✓ should be defined (14 ms)
    ✓ should create a solicitud (4 ms)
    ✕ should update a solicitud (3 ms)

  ● SolicitudController › should update a solicitud

    TypeError: this.solicitudService.update is not a function <b class="conum">(2)</b>

      43 |     @Body() updateSolicitudDto: UpdateSolicitudDto,
      44 |   ): Promise&lt;Solicitud&gt; {
    &gt; 45 |     return this.solicitudService.update(+id, updateSolicitudDto); <b class="conum">(3)</b>
         |                                  ^
      46 |   }
      47 |
      48 |   @Delete(':id')

      at SolicitudController.update (solicitud/solicitud.controller.ts:45:34)
      at Object.&lt;anonymous&gt; (solicitud/solicitud.controller.spec.ts:74:23)</code></pre>
</div>
</div>
<div class="olist arabic data-line-1389">
<ol class="arabic">
<li class="data-line-1389">
<p>El test no pasa</p>
</li>
<li class="data-line-1390">
<p>El método <code>update</code> no existe en el mock del servicio (recordamos que estamos en el mockeado)</p>
</li>
<li class="data-line-1391">
<p>Línea en la que se provoca el error en el test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1393">
<p>Para solucionar este problema añadiremos la función <code>update</code> a <code>mockSolicitudService</code>. Con los cambios, quedará así</p>
</div>
<div class="listingblock data-line-1396">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let mockSolicitudService = {
    create: jest.fn((dto) =&gt; {
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    update: jest.fn((id, dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: id,
        ...dto,
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1416">
<ol>
<li>
<p><code>update</code> devolverá el nuevo objeto modificado</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1418">
<p>Tras los cambios, los tests volverán a pasar.</p>
</div>
<div class="listingblock data-line-1421">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/solicitud/solicitud.controller.spec.ts
  SolicitudController
    ✓ should be defined (19 ms)
    ✓ should create a solicitud (6 ms)
    ✓ should update a solicitud (3 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        4.209 s
Ran all test suites related to changed files.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="paragraph data-line-1437">
<p>Por último, es posible introducir una mejora al test para comprobar que el servicio fue llamado con los argumentos correctos. Esta comprobación va dirigida a conocer si el controlador introduce alguna anomalía al llamar al servicio. Con esto, no sólo nos aseguramos que el controlador hace su trabajo y devuelve los datos correctos, sino que también comprobamos que internamente hace bien su trabajo.</p>
</div>
<div class="paragraph data-line-1439">
<p>Tras los cambios el test quedaría así:</p>
</div>
<div class="listingblock data-line-1442">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should update a solicitud', () =&gt; {
    const updateSolicitudDto: UpdateSolicitudDto = {
      nombre: 'John Smith',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 1;

    expect(controller.update(solicitudId, updateSolicitudDto)).toEqual({
      id: solicitudId,
      ...updateSolicitudDto,
    });

    expect(mockSolicitudService.update).toHaveBeenCalledWith( <b class="conum">(1)</b>
      solicitudId,
      updateSolicitudDto,
    );
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1473">
<ol>
<li>
<p>Comprobación de que el servicio ha sido llamado con los argumentos correctos por parte del controlador</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1475">
<p>Al guardar, se volverán a pasar los tests y el cambio introducido funcionará correctamente, lo que permitirá validar que el controlador hace bien su trabajo.</p>
</div>
<div class="paragraph data-line-1477">
<p>Ahora, y de acuerdo con el informe de cobertura de tests, se trataría de ir añadiendo los tests que faltan (mostrar solicitudes, mostrar una solicitud y eliminar una solicitud). Los dejaremos para más adelante y ahora pasaremos a ver cómo llevar el mock del servicio a una clase aparte para no tenerlo mezclado con el test del controlador.</p>
</div>
</div>
<div class="sect3 data-line-1479">
<h4 id="_tercer_paso_llevar_el_mock_del_servicio_a_una_clase">3.2.3. Tercer paso. Llevar el mock del servicio a una clase</h4>
<div class="paragraph data-line-1481">
<p>Hasta ahora hemos mockeado el servicio en la misma clase de testing. Aquí veremos como refactorizar el archivo de testing sacando el mock a una clase aparte. Concretamente, se trata de llevar el contenido de los métodos de <code>mockSolicitudService</code> a métodos en una clase nueva.</p>
</div>
<div class="paragraph data-line-1483">
<p>Partimos del servicio mockeado en la propia clase, que recordamos que tenía esta forma:</p>
</div>
<div class="listingblock data-line-1486">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">...
  let mockSolicitudService = {
    create: jest.fn((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    update: jest.fn((id, dto) =&gt; { <b class="conum">(2)</b>
      return {
        id: id,
        ...dto,
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1505">
<ol>
<li>
<p>Función de mock para crear solicitudes</p>
</li>
<li>
<p>Función de mock para modificar solicitudes</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1507">
<p>Comenzamos generando la clase que actuará como mock del servicio con el CLI de NestJS. La situaremos en la misma carpeta que el resto de componentes de la solicitud.</p>
</div>
<div class="listingblock data-line-1510">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ nest g class solicitud/SolicitudServiceMock --no-spec <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-1513">
<ol>
<li>
<p>Incluimos el parámetro <code>--no-spec</code> para que no cree el archivo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1515">
<p>Esta clase estará inicialmente vacía:</p>
</div>
<div class="listingblock data-line-1518">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">export class SolicitudServiceMock {}</code></pre>
</div>
</div>
<div class="paragraph data-line-1522">
<p>Ahora se trata de traer a esta nueva clase de mock el código que había en los métodos <code>create</code> y <code>update</code> del objeto <code>mockSolicitudService</code> en el archivo de testing del controlador. Para ello, crearemos en la clase dos métodos <code>create</code> y <code>update</code> en los que incluiremos el código de mocking que ya teníamos. No obstante, renombraremos los DTO para darle una mayor semántica. Además, haremos que los métodos devuelvan promesas, tal y como lo hacen en el servicio real.</p>
</div>
<div class="paragraph data-line-1524">
<p>La clase que mockea al servicio ahora quedará así:</p>
</div>
<div class="listingblock data-line-1527">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { CreateSolicitudDto } from './dto/create-solicitud.dto';
import { Solicitud } from './entities/solicitud.entity';
import { UpdateSolicitudDto } from './dto/update-solicitud.dto';
export class SolicitudServiceMock {
  async create(createSolicitudDto: CreateSolicitudDto): Promise&lt;Solicitud&gt; { <b class="conum">(1)</b>
    return Promise.resolve({ <b class="conum">(2)</b>
      id: Math.random() * (1000 - 1) + 1,
      ...createSolicitudDto,
    });
  }

  async update(
    id: number,
    updateSolicitudDto: UpdateSolicitudDto,
  ): Promise&lt;Solicitud&gt; { <b class="conum">(3)</b>
    return Promise.resolve({ <b class="conum">(4)</b>
      id: id,
      ...updateSolicitudDto,
    }) as Promise&lt;Solicitud&gt;; <b class="conum">(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-1555">
<ol>
<li>
<p>Método <code>create</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudService</code></p>
</li>
<li>
<p>Método <code>update</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudService</code></p>
</li>
<li>
<p>Forzamos el casting de la respuesta porque no pueden inferir que el tipo que devolvemos es correcto.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1557">
<p>Una vez que disponemos de la clase que mockea el servicio, <strong>haremos los cambios en el archivo de tests del controlador para que use esta clase mockeada en lugar de la variable <code>mockSolicitudService</code></strong>, que es la que contenía la implementación de los mocks.</p>
</div>
<div class="admonitionblock note data-line-1560">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-1561">
<p>La inyección de dependencias de NestJS permite que podamos sustituir el servicio que se usa para ejecutar los tests. El uso de mocks permite probar sólo una parte del código haciendo que el resto ofrezca valores falseados/generados. Esto, además de permitirnos un mayor control en el proceso de testing, acelera la ejecución de los tests, ya que el servicio ya no tiene que usar la base de datos (que siempre ofrece mayor latencia) para realizar su trabajo en el testing del controlador.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-1564">
<p>Hay que hacer varios cambios:</p>
</div>
<div class="olist arabic data-line-1566">
<ol class="arabic">
<li class="data-line-1566">
<p>Declarar una variable <code>service</code> de tipo <code>SolicitudService</code></p>
</li>
<li class="data-line-1567">
<p>Definir un <code>SolicitudServiceProvider</code> que mockee el provider <code>SolicitudService</code></p>
</li>
<li class="data-line-1568">
<p>Incorporar el <code>SolicitudServiceProvider</code> a la lista de providers del módulo de testing</p>
</li>
<li class="data-line-1569">
<p>Usar la clase de mock para construir el módulo de testing</p>
</li>
<li class="data-line-1570">
<p>Inicializar la variable <code>service</code> al servicio de la solicitud. Como <code>SolicitudService</code> está mockeado realmente no usará la implementación original</p>
</li>
<li class="data-line-1571">
<p>Cambiar los tests a asíncronos</p>
</li>
<li class="data-line-1572">
<p>Añadir <code>await</code> a las llamadas a los métodos del controlador</p>
</li>
<li class="data-line-1573">
<p>Usar espías de métodos si usamos métodos como <code>toHaveBeenCalledWith</code></p>
</li>
</ol>
</div>
<div class="listingblock data-line-1576">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudController } from './solicitud.controller';
import { SolicitudService } from './solicitud.service';
import { CreateSolicitudDto } from './dto/create-solicitud.dto';
import { UpdateSolicitudDto } from './dto/update-solicitud.dto';
import { of } from 'rxjs';
import { SolicitudServiceMock } from './solicitud-service-mock';

describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let service: SolicitudService; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const SolicitudServiceProvider = { <b class="conum">(2)</b>
      provide: SolicitudService,
      useClass: SolicitudServiceMock,
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [SolicitudController],
      providers: [SolicitudService, SolicitudServiceProvider], <b class="conum">(3)</b>
    })
      .overrideProvider(SolicitudService)
      .useClass(SolicitudServiceMock) <b class="conum">(4)</b>
      .compile();

    controller = module.get&lt;SolicitudController&gt;(SolicitudController);
    service = module.get&lt;SolicitudService&gt;(SolicitudService); <b class="conum">(5)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });

  it('should create a solicitud', async () =&gt; { <b class="conum">(6)</b>
    const createSolicitudDto: CreateSolicitudDto = {
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };

    expect(await controller.create(createSolicitudDto)).toEqual({ <b class="conum">(7)</b>
      id: expect.any(Number),
      ...createSolicitudDto,
    });
  });

  it('should update a solicitud', async () =&gt; { <b class="conum">(8)</b>
    const updateSolicitudDto: UpdateSolicitudDto = {
      nombre: 'John Smith',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 1;

    expect(await controller.update(solicitudId, updateSolicitudDto)).toEqual({ <b class="conum">(9)</b>
      id: solicitudId,
      ...updateSolicitudDto,
    });

    const updateSpy = jest.spyOn(service, 'update'); <b class="conum">(10)</b>
    controller.update(solicitudId, updateSolicitudDto); <b class="conum">(11)</b>

    expect(updateSpy).toHaveBeenCalledWith(solicitudId, updateSolicitudDto); <b class="conum">(12)</b>
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-1673">
<ol>
<li>
<p>Declaración del servicio</p>
</li>
<li>
<p><code>SolicitudServiceProvider</code> mockea el provider <code>SolicitudService</code></p>
</li>
<li>
<p>Se añade <code>SolicitudServiceProvider</code> como otro provider</p>
</li>
<li>
<p>Inicialización del mock a la clase del mock del servicio (Inyección de dependencias)</p>
</li>
<li>
<p>Inicialización del servicio al servicio de la solicitud, que está mockeado</p>
</li>
<li>
<p>Caso de prueba asíncrono por el <code>await</code> en métodos dentrol del caso de prueba</p>
</li>
<li>
<p>Probamos que la solicitud se crea correctamente y devuelve los valores esperados. La ejecución se hace con <code>await</code></p>
</li>
<li>
<p>Caso de prueba asíncrono por el <code>await</code> en métodos dentro del caso de prueba</p>
</li>
<li>
<p>Probamos que la actualización de una solicitud se realiza correctamente y devuelve los valores esperados. La ejecución se hace con <code>await</code></p>
</li>
<li>
<p>Crear un espía para el método <code>update</code> en <code>service</code></p>
</li>
<li>
<p>Hacer una actualización de solicitud</p>
</li>
<li>
<p>Probamos que el servicio espiado ha sido llamado por el controlador con los parámetros adecuados</p>
</li>
</ol>
</div>
<div class="sidebarblock data-line-1676">
<div class="content">
<div class="title"><code>jest.spyOn()</code></div>
<div class="paragraph data-line-1677">
<p><code>jest.spyOn()</code> crea una función de mock similar a <code>jest.fn()</code> pero además, monitoriza/fisgonea las llamadas al método que se le proporcione.</p>
</div>
<div class="paragraph data-line-1679">
<p><code>jest.spyOn(objeto, nombre-de-método-a-espiar)</code> devuelve una función que se comporta como espía monitorizando las llamadas que se realicen al método del objeto que se pasen como argumentos.</p>
</div>
<div class="listingblock data-line-1682">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
let service: SolicitudService; <b class="conum">(1)</b>
...
service = module.get&lt;SolicitudService&gt;(SolicitudService); <b class="conum">(2)</b>
...

const updateSpy = jest.spyOn(service, 'update'); <b class="conum">(3)</b>
controller.update(solicitudId, updateSolicitudDto); <b class="conum">(4)</b>

expect(updateSpy).toHaveBeenCalledWith(solicitudId, updateSolicitudDto); <b class="conum">(5)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1700">
<ol>
<li>
<p>Declaración de un objeto <code>service</code></p>
</li>
<li>
<p>Inicialización del objeto <code>service</code> (a la clase del servicio)</p>
</li>
<li>
<p>Espiar el método <code>update</code> del objeto <code>service</code>. Ahora, <code>updateSpy</code>
monitoriza cada una de las llamadas que se hagan al método <code>update</code> del objeto <code>service</code>.</p>
</li>
<li>
<p>Llamar al método espiado (<code>update</code>)</p>
</li>
<li>
<p>Comprobar a través del espía (<code>updateSpy</code>) los argumentos con los que ha sido llamada la función espiada.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1702">
<p>La función espía intercepta/espía las llamadas que se hacen a un método de un objeto. Haciendo la analogía, el método <code>update</code> del objeto <code>service</code> está <em>pinchado</em>, como se <em>pinchan</em> los teléfonos en espionaje.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1705">
<h3 id="_tests_del_servicio">3.3. Tests del servicio</h3>
<div class="paragraph data-line-1707">
<p>Una vez creados los tests del controlador procederemos a realizar los tests del servicio. De forma análoga a como hicimos con el controlador, que mockeaba el servicio del que dependía, en los tests del servicio también mockearamos sus dependencias. En el caso del servicio se mockea el repositorio, que es su dependencia.</p>
</div>
<div class="paragraph data-line-1709">
<p>Comenzamos lanzando los tests en modo <code>watch</code>, pero limitados al patrón <code>solicitud.service</code></p>
</div>
<div class="listingblock data-line-1712">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:watch</code></pre>
</div>
</div>
<div class="paragraph data-line-1716">
<p>El resultado de los tests nos devolverá que no se pueden resolver las dependencias de <code>SolicitudService</code>. Esto se debe a que <code>SolicitudService</code> tiene una dependencia con el repositorio <code>SolicitudRepository</code> y no se puede resolver en el entorno de pruebas.</p>
</div>
<div class="paragraph data-line-1718">
<p>Recordemos la definición del servicio en <code>solicitud/solicitud.service.ts</code></p>
</div>
<div class="listingblock data-line-1720">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Injectable()
export class SolicitudService {
  constructor(
    @InjectRepository(Solicitud)
    private solicitudRepository: Repository&lt;Solicitud&gt;, <b class="conum">(1)</b>
  ) {}
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1730">
<ol>
<li>
<p>Dependencia del servicio respecto del repositorio</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1732">
<p>De foma análoga a los tests del controlador, en el código siguiente del test del servicio, generado por el CLI de NestJS al generar el servicio, vemos que dentro de <code>beforeEach</code> se usa la clase <code>Test</code> y un método <code>createTestingModule</code>. Este método toma los mismos argumentos que se usan para crear un módulo (p.e. <code>imports</code>, <code>providers</code>, <code>controllers</code>, …​). Tras definir el nuevo módulo (el de testing) y llamar al método <code>compile</code> se crea el módulo con sus dependencias similar a los módulos creados para el entorno de ejecución.</p>
</div>
<div class="paragraph data-line-1735">
<p>Archivo <code>src/solicitud/solicitud.service.spec.ts</code></p>
</div>
<div class="listingblock data-line-1737">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudService', () =&gt; {
  let service: SolicitudService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({ <b class="conum">(1)</b>
      providers: [SolicitudService], <b class="conum">(2)</b>
    }).compile();

    service = module.get&lt;SolicitudService&gt;(SolicitudService); <b class="conum">(3)</b>
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1753">
<ol>
<li>
<p>Definición del módulo para el testing del servicio</p>
</li>
<li>
<p>Provider del servicio</p>
</li>
<li>
<p>Creación de una instancia del servicio</p>
</li>
</ol>
</div>
<div class="sect3 data-line-1755">
<h4 id="_primer_paso_evitar_que_falle_el_test_2">3.3.1. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-1757">
<p>Al igual que hicimos con el controlador, seguiremos un enfoque progresivo para conseguir que nuestros tests funcionen. Se trata de ayudar a que en primer lugar desaparezcan los errores de las pruebas del servicio. Posteriormente, se irán refinando los tests.</p>
</div>
<div class="paragraph data-line-1759">
<p>Inicialmente, el test del servicio falla porque el servicio no es capaz de resolver sus dependencias. Lo que haremos es sustituir el repositorio original por un repositorio de uso exclusivo en testing. Con esto, conseguiremos probar únicamente el servicio, aislándolo del repositorio, que es la premisa de los tests unitarios: probar sólo una cosa en cada test.</p>
</div>
<div class="paragraph data-line-1761">
<p>Pasos:</p>
</div>
<div class="olist arabic data-line-1763">
<ol class="arabic">
<li class="data-line-1763">
<p>Crearemos un objeto <code>mockSolicitudRepository</code> que sustituya (mockee) al repositorio. Inicialmente <code>mockSolicitudRepository</code> estará vacío. Posteriormente le iremos añadiendo los métodos falseados (mockeados).</p>
</li>
<li class="data-line-1764">
<p>Construir un módulo de testing que reemplace el repositorio original de solicitudes por el mockeado que hemos creado en el paso anterior.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-1767">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudService } from './solicitud.service';
import { Solicitud } from './entities/solicitud.entity';
import { getRepositoryToken } from '@nestjs/typeorm';

describe('SolicitudService', () =&gt; {
  let service: SolicitudService;
  let mockSolicitudRepository = {}; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SolicitudService,
        { <b class="conum">(2)</b>
          provide: getRepositoryToken(Solicitud), <b class="conum">(3)</b>
          useValue: mockSolicitudRepository, <b class="conum">(4)</b>
        },
      ],
    }).compile(); <b class="conum">(5)</b>

    service = module.get&lt;SolicitudService&gt;(SolicitudService);
  });

  it('should be defined', () =&gt; {
    expect(service).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-1801">
<ol>
<li>
<p>Mock del repositorio. Inicialmente vacío para pasar el test</p>
</li>
<li>
<p>Nuevo provider</p>
</li>
<li>
<p>Repositorio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Repositorio que sustituye (mockea) al original. Usamos el creado en el paso 1</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1803">
<p>Tras guardar los cambios ahora vemos que ya pasan los tests.</p>
</div>
<div class="listingblock data-line-1806">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/solicitud/solicitud.service.spec.ts
  SolicitudService
    ✓ should be defined (13 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        4.758 s, estimated 6 s
Ran all test suites matching /solicitud.service/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1820">
<h4 id="_segundo_paso_añadir_tests_2">3.3.2. Segundo paso. Añadir tests</h4>
<div class="paragraph data-line-1822">
<p>Una vez que hemos configurado el módulo para que el test no falle mediante el mockeo del repositorio, vamos a ir creando tests del servicio. Comenzaremos por el de creación de solicitudes añadiendo este test después del test <code>should be defined</code>. Con este nuevo test definimos un nuevo DTO para crear una solicitud y esperamos que nos devuelva un objeto con un id (da igual el que sea. En el código de producción sería el <code>id</code> que generaría la base de datos) y el resto de campos coincidirán con los del DTO de creación de solicitud.</p>
</div>
<div class="listingblock data-line-1825">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should create a solicitud', async () =&gt; {
    const createSolicitudDto: CreateSolicitudDto = { <b class="conum">(1)</b>
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };

    expect(await service.create(createSolicitudDto)).toEqual({ <b class="conum">(2)</b>
      id: expect.any(Number),
      ...createSolicitudDto,
    });
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1851">
<ol>
<li>
<p>DTO de la solicitud a crear</p>
</li>
<li>
<p>Probamos que la solicitud creada consiste en un <code>id</code> junto a los datos proporcionados en el DTO para crear la solicitud</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1853">
<p>Tras guardar los cambios, como estamos en modo <code>watch</code> se volverán a pasar los tests y nos da un fallo: el método <code>create</code> no existe en el mock del repositorio, tal y como se muestra a continuación:</p>
</div>
<div class="listingblock data-line-1856">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  src/solicitud/solicitud.service.spec.ts
  SolicitudService
    ✓ should be defined (12 ms)
    ✕ should create a solicitud (3 ms)

  ● SolicitudService › should create a solicitud

    TypeError: this.solicitudRepository.save is not a function

      13 |   ) {}
      14 |   async create(createSolicitudDto: CreateSolicitudDto): Promise&lt;Solicitud&gt; {
    &gt; 15 |     return await this.solicitudRepository.save(createSolicitudDto);
         |                                           ^
      16 |   }
      17 |
      18 |   async findAll(): Promise&lt;Solicitud[]&gt; {

      at SolicitudService.create (solicitud/solicitud.service.ts:15:43)
      at Object.&lt;anonymous&gt; (solicitud/solicitud.service.spec.ts:45:26)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        3.966 s, estimated 5 s
Ran all test suites matching /solicitud.service/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="colist arabic data-line-1887">
<ol>
<li>
<p>El test no pasa</p>
</li>
<li>
<p>El método <code>save</code> no existe en el mock del repositorio (recordamos que estamos en el mockeado)</p>
</li>
<li>
<p>Línea en la que se provoca el error en el test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1889">
<p>El error se debe a que en la sección anterior creamos el mock del repositorio de la solicitud pero lo creamos vacío, sin ningún método, tal y como se recuerda a continuación.</p>
</div>
<div class="listingblock data-line-1892">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudService', () =&gt; {
  let service: SolicitudService;
  let mockSolicitudRepository = {}; <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1899">
<ol>
<li>
<p>Mock del repositorio creado vacío inicialmente</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1901">
<p>A continuación crearemos la implementación que mockea al método <code>save</code> del repositorio. Se limitará a tomar un DTO y devolver un objeto con un <code>id</code> aleatorio  (simulando lo que haría la base de datos) y el DTO.</p>
</div>
<div class="paragraph data-line-1903">
<p>Archivo <code>src/solicitud/solicitud.service.spec.ts</code></p>
</div>
<div class="listingblock data-line-1906">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudService', () =&gt; {
  let service: SolicitudService;
  let mockSolicitudRepository = {
    save: jest.fn().mockImplementation((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
        ...dto, <b class="conum">(3)</b>
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-1922">
<ol>
<li>
<p>Método <code>save</code> mockeado.</p>
</li>
<li>
<p><code>id</code> aleatorio</p>
</li>
<li>
<p>Incorporar el DTO del objeto a crear</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1924">
<p>Una vez realizados estos cambios, el test de crear una solicitud pasa correctamente.</p>
</div>
<div class="listingblock data-line-1927">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/solicitud/solicitud.service.spec.ts
  SolicitudService
    ✓ should be defined (12 ms)
    ✓ should create a solicitud (4 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        3.673 s
Ran all test suites matching /solicitud.service/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="paragraph data-line-1942">
<p>A continuación añadiremos otro test. Por ejemplo, añadiremos el test para actualizar una solicitud. Comenzaremos creando el test en <code>src/solicitud/solicitud.service.spec.ts</code>. Lo añadiremos a continuación de los otros tests definidos.</p>
</div>
<div class="listingblock data-line-1945">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">  it('should update a solicitud', async () =&gt; {
    const updateSolicitudDto: UpdateSolicitudDto = { <b class="conum">(1)</b>
      nombre: 'John Smith', <b class="conum">(2)</b>
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 1; <b class="conum">(3)</b>

    expect(await service.update(solicitudId, updateSolicitudDto)).toEqual({ <b class="conum">(4)</b>
      id: solicitudId,
      ...updateSolicitudDto,
    });
  });</code></pre>
</div>
</div>
<div class="colist arabic data-line-1972">
<ol>
<li>
<p>DTO con los cambios de la solicitud</p>
</li>
<li>
<p>Cambio introducido</p>
</li>
<li>
<p><code>id</code>  de la solicitud  a modificar</p>
</li>
<li>
<p>Se espera que resultado de actualizar la solicitud sea la solicitud con el <code>id</code> y los datos actualizados</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1974">
<p>Tras guardar los cambios se volverán a pasar los tests y no pasará este test porque no está definido el método <code>findOne</code> en el mock del repositorio.</p>
</div>
<div class="listingblock data-line-1977">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  src/solicitud/solicitud.service.spec.ts
  SolicitudService
    ✓ should be defined (13 ms)
    ✓ should create a solicitud (4 ms)
    ✕ should update a solicitud (3 ms)

  ● SolicitudService › should update a solicitud

    TypeError: this.solicitudRepository.findOne is not a function <b class="conum">(1)</b>

      28 |     updateSolicitudDto: UpdateSolicitudDto,
      29 |   ): Promise&lt;Solicitud&gt; {
    &gt; 30 |     let toUpdate = await this.solicitudRepository.findOne(id);
         |                                                   ^
      31 |
      32 |     let updated = Object.assign(toUpdate, updateSolicitudDto);
      33 |</code></pre>
</div>
</div>
<div class="paragraph data-line-1997">
<p>Para solucionar este problema añadiremos la función <code>findOne</code> a <code>solicitudRepository</code> que devuelva un objeto <code>Solicitud</code> completo. Con los cambios, quedará así:</p>
</div>
<div class="paragraph data-line-1999">
<p>Archivo <code>solicitud/solicitud.service.spec.ts</code>:</p>
</div>
<div class="listingblock data-line-2001">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  let mockSolicitudRepository = {
    save: jest.fn().mockImplementation((dto) =&gt; {
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    findOne: jest.fn().mockImplementation((id) =&gt; { <b class="conum">(1)</b>
      return {
        id: id, <b class="conum">(2)</b>
        nombre: 'John Doe',
        cargo: 'Assistant Professor',
        unidad: 'Informatics Department',
        telefono: '1234',
        email: 'john.doe@gmail.com',
        tipo: '',
        nombreActividad: '',
        start: undefined,
        end: undefined,
        dia: '',
        horaInicio: '',
        horaFin: '',
      };
    }),
  };</code></pre>
</div>
</div>
<div class="colist arabic data-line-2030">
<ol>
<li>
<p><code>findOne</code> devolverá un objeto <code>Solicitud</code> completo como lo devolvería la base de datos</p>
</li>
<li>
<p>Simulamos que devolvemos el mismo <code>id</code> con el que hacemos la consulta</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2032">
<p>Tras los cambios, los tests volverán a pasar.</p>
</div>
<div class="listingblock data-line-2035">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code"> PASS  src/solicitud/solicitud.service.spec.ts
  SolicitudService
    ✓ should be defined (13 ms)
    ✓ should create a solicitud (4 ms)
    ✓ should update a solicitud (2 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        4.159 s
Ran all test suites matching /solicitud.service/i.</code></pre>
</div>
</div>
<div class="paragraph data-line-2049">
<p>Ahora, y de acuerdo con el informe de cobertura de tests, se trataría de ir añadiendo los tests que faltan (mostrar solicitudes, mostrar una solicitud y eliminar una solicitud). Los dejaremos para más adelante y ahora pasaremos a ver cómo llevar el mock del repositorios a una clase aparte para no tenerlo mezclado con el test del servicio.</p>
</div>
</div>
<div class="sect3 data-line-2051">
<h4 id="_tercer_paso_llevar_el_mock_del_repositorio_a_una_clase">3.3.3. Tercer paso. Llevar el mock del repositorio a una clase</h4>
<div class="paragraph data-line-2053">
<p>Hasta ahora hemos mockeado el repositorio en la misma clase de testing. Aquí veremos como refactorizar el archivo de testing sacando el mock a una clase aparte. Concretamente se trata de llevar el contenido de los métodos de <code>mockSolicitudRepository</code> a métodos en una clase nueva.</p>
</div>
<div class="paragraph data-line-2055">
<p>Partimos del repositorio mockeado en la propia clase y tenía esta forma:</p>
</div>
<div class="listingblock data-line-2058">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
 let mockSolicitudRepository = {
    save: jest.fn().mockImplementation((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    findOne: jest.fn().mockImplementation((id) =&gt; { <b class="conum">(2)</b>
      return {
        id: id,
        nombre: 'John Doe',
        cargo: 'Assistant Professor',
        unidad: 'Informatics Department',
        telefono: '1234',
        email: 'john.doe@gmail.com',
        tipo: '',
        nombreActividad: '',
        start: undefined,
        end: undefined,
        dia: '',
        horaInicio: '',
        horaFin: '',
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2088">
<ol>
<li>
<p>Método para guardar solicitudes</p>
</li>
<li>
<p>Método para buscar una solicitud</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2090">
<p>Comenzamos generando la clase con el CLI de NestJS</p>
</div>
<div class="listingblock data-line-2093">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ nest g class solicitud/SolicitudRepositoryMock --no-spec <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-2096">
<ol>
<li>
<p>Incluimos el parámetro --no-spec para que no cree el archivo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2098">
<p>Esta clase estará inicialmente vacía:</p>
</div>
<div class="listingblock data-line-2101">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ export class SolicitudRepositoryMock {}</code></pre>
</div>
</div>
<div class="paragraph data-line-2105">
<p>Ahora se trata de traer a esta nueva clase de mock el código que había en los métodos <code>save</code> y <code>findOne</code> del objeto <code>SolicitudServiceMock</code> en el archivo de testing del servicio. Para ello, crearemos en la clase dos métodos <code>save</code> y <code>findOne</code> en los que incluiremos el código de mocking que ya teníamos. No obstante, renombraremos los DTO para darle una mayor semántica. Además, haremos que los métodos devuelvan promesas, tal y como lo hacen en el repositorio real.</p>
</div>
<div class="paragraph data-line-2107">
<p>La clase que mockea al repositorio ahora quedará así:</p>
</div>
<div class="listingblock data-line-2110">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">import { Solicitud } from './entities/solicitud.entity';
export class SolicitudRepositoryMock {
  save(solicitud: Solicitud): Promise&lt;Solicitud&gt; { <b class="conum">(1)</b>
    return Promise.resolve({
      id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
      ...solicitud,
    });
  }

  findOne(id: number): Promise&lt;Solicitud&gt; { <b class="conum">(3)</b>
    return Promise.resolve({ <b class="conum">(4)</b>
      id: id,
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    });
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-2142">
<ol>
<li>
<p>Método <code>save</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudRepository</code> pero envuelto en una promesa</p>
</li>
<li>
<p>Método <code>findOne</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudRepository</code> pero envuelto en una promesa</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2144">
<p>Una vez que disponemos de la clase que mockea el repositorio, <strong>haremos los cambios en el archivo de tests del servicio para que use esta clase mockeada en lugar de la variable <code>mockSolicitudRepository</code></strong>, que es la que contenía la implementación de los mocks. Basta con:</p>
</div>
<div class="olist arabic data-line-2146">
<ol class="arabic">
<li class="data-line-2146">
<p>Eliminar la variable <code>mockSolicitudRepository</code></p>
</li>
<li class="data-line-2147">
<p>Usar la clase de mock para construir el módulo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2149">
<p>La clase de testing quedaría así</p>
</div>
<div class="listingblock data-line-2152">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudService } from './solicitud.service';
import { Solicitud } from './entities/solicitud.entity';
import { getRepositoryToken } from '@nestjs/typeorm';
import { CreateSolicitudDto } from './dto/create-solicitud.dto';
import { UpdateSolicitudDto } from './dto/update-solicitud.dto';
import { SolicitudRepositoryMock } from './solicitud-repository-mock';

describe('SolicitudService', () =&gt; {
  let service: SolicitudService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SolicitudService,
        {
          provide: getRepositoryToken(Solicitud),
          useClass: SolicitudRepositoryMock, <b class="conum">(1)</b>
        },
      ],
    }).compile();

    service = module.get&lt;SolicitudService&gt;(SolicitudService);
  });

  it('should be defined', () =&gt; {
    expect(service).toBeDefined();
  });

  it('should create a solicitud', async () =&gt; {
    const createSolicitudDto: CreateSolicitudDto = {
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };

    expect(await service.create(createSolicitudDto)).toEqual({
      id: expect.any(Number),
      ...createSolicitudDto,
    });
  });

  it('should update a solicitud', async () =&gt; {
    const updateSolicitudDto: UpdateSolicitudDto = {
      nombre: 'John Smith',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 1;

    expect(await service.update(solicitudId, updateSolicitudDto)).toEqual({
      id: solicitudId,
      ...updateSolicitudDto,
    });
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-2228">
<ol>
<li>
<p>Inicialización del mock a la clase del mock del repositorio</p>
</li>
</ol>
</div>
<div class="admonitionblock note data-line-2231">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-2232">
<p>La inyección de dependencias de NestJS permite que podamos sustituir el repositorio que se usa para ejecutar los tests. El uso de mocks permite probar sólo una parte del código haciendo que el resto ofrezca valores falseados/generados. Esto, además de permitirnos un mayor control en el proceso de testing, acelera la ejecución de los tests, ya que el servicio ya no tiene que usar la base de datos (que siempre ofrece mayor latencia) para realizar su trabajo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2 data-line-2235">
<h3 id="_tests_end_to_end">3.4. Tests end to end</h3>
<div class="paragraph data-line-2237">
<p>Este tipo de tests se centra más en la interacción entre clases y módulos a un nivel más alto, en la línea de cómo interactuarían los usuarios con la aplicación. Con esto podremos realizar la prueba de cada endpoint de la API. Para simular las llamadas HTTP NestJS usa <a href="https://github.com/visionmedia/supertest" data-href="https://github.com/visionmedia/supertest">Supertest</a> .</p>
</div>
<div class="admonitionblock tip data-line-2240">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph data-line-2241">
<p>Para el desarrollo de nuestros tests seguiremos apoyándonos en que NestJS permite la inyección de dependencias de forma que podremos mockear o sustituir componentes fácilmente en el entorno de pruebas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 data-line-2244">
<h4 id="_añadir_script_para_tests_e2e_en_modo_watch">3.4.1. Añadir script para tests e2e en modo <code>watch</code></h4>
<div class="paragraph data-line-2246">
<p>Podemos lanzar las pruebas e2e generadas al crear el proyecto con el CLI de NestJS. En <code>package.json</code> hay un script para ello: <code>test:e2e</code>. Pero antes de lanzar los tests vamos a introducir un script en <code>package.json</code> para que los tests e2e también se ejecuten en modo <code>watch</code>. Añadiremos los cambios al final del elemento <code>scripts</code>:</p>
</div>
<div class="paragraph data-line-2248">
<p>Archivo <code>package.json</code></p>
</div>
<div class="listingblock data-line-2251">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">...
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "test:e2e:watch": "jest --config ./test/jest-e2e.json --watch" <b class="conum">(1)</b>
  },
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2271">
<ol>
<li>
<p>Nueva etiqueta <code>test:e2e:watch</code> para tests e2e en modo <code>watch</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3 data-line-2273">
<h4 id="_primer_paso_evitar_que_falle_el_test_3">3.4.2. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-2275">
<p>Comenzaremos haciendo una copia de <code>test/app.e2e-spec.ts</code>. La nueva copia se denominará <code>test/solicitud.e2e-spec.ts</code>. Responderemos que Sí a que se actualicen todas las importaciones en el archivo copiado.</p>
</div>
<div class="admonitionblock note data-line-2278">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-2279">
<p>De forma predeterminada se ejecutarán como tests e2e todos los que incluyan <code>e2e-spec.ts</code> en su nombre de archivo. Esto se configura en el archivo <code>test/jest-e2e.json</code> y queda configurado automáticamente al crear el proyecto con el CLI de NestJS.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2282">
<p>Si ejecutamos los tests e2e con el script <code>test:e2e:watch</code></p>
</div>
<div class="listingblock data-line-2285">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:e2e:watch</code></pre>
</div>
</div>
<div class="paragraph data-line-2289">
<p>indicando como patrón <code>solicitud.e2e</code> todo funcionará correctamente por ahora ya que es una copia exacta de <code>app.e2e-spec.ts</code></p>
</div>
<div class="listingblock data-line-2292">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/solicitud.e2e-spec.ts
  AppController (e2e)
    ✓ / (GET) (295 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        4.954 s
Ran all test suites matching /solicitud.e2e/i.</code></pre>
</div>
</div>
<div class="paragraph data-line-2304">
<p>Sin embargo, una vez que comencemos a personalizar el archivo de testing para que funcione con el módulo de solicitudes en lugar del módulo de la aplicación empezarán los problemas.</p>
</div>
<div class="paragraph data-line-2306">
<p>Comencemos introduciendo los cambios siguientes en `test/solicitud.e2e-spec.ts:</p>
</div>
<div class="olist arabic data-line-2308">
<ol class="arabic">
<li class="data-line-2308">
<p>Cambiar la descripción de <code>describe</code> para que sea para solicitudes</p>
</li>
<li class="data-line-2309">
<p>Sustituir el módulo</p>
</li>
</ol>
</div>
<div class="listingblock data-line-2312">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('SolicitudController (e2e)', () =&gt; { <b class="conum">(1)</b>
  let app: INestApplication;

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [SolicitudModule], <b class="conum">(2)</b>
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2328">
<ol>
<li>
<p>Modificación de la descripción del bloque de tests</p>
</li>
<li>
<p>Uso del módulo de solicitudes</p>
</li>
</ol>
</div>
<div class="listingblock data-line-2331">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  test/solicitud.e2e-spec.ts
  SolicitudController (e2e)
    ✕ / (GET) (14 ms)

  ● SolicitudController (e2e) › / (GET)

    Nest can't resolve dependencies of the SolicitudRepository (?). Please make sure that the argument Connection at index [0] is available in the TypeOrmModule context.</code></pre>
</div>
</div>
<div class="paragraph data-line-2341">
<p>El error indica que el módulo de testing creado para la ocasión no es capaz de resolver las dependencias que hay sobre el repositorio de <code>SolicitudRepository</code>. De forma análoga a como hemos hecho con los tests del controlador y del servicio, hay que añadir un mock que permita resolver la dependencia existente. Lo más inmediato es hacer lo mínimo para que el test deje de ejecutarse con errores. A continuación se muestran los cambios realizados.</p>
</div>
<div class="paragraph data-line-2343">
<p>Archivo <code>test/solicitud.e2e-spec.ts</code></p>
</div>
<div class="listingblock data-line-2344">
<div class="content">
<pre>import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { SolicitudModule } from '../src/solicitud/solicitud.module';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Solicitud } from '../src/solicitud/entities/solicitud.entity';

describe('SolicitudController (e2e)', () =&gt; {
  let app: INestApplication;
  const mockSolicitudRepository = { <b class="conum">(1)</b>
    find: jest.fn(),
  };

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [SolicitudModule], <b class="conum">(2)</b>
    })
      .overrideProvider(getRepositoryToken(Solicitud)) <b class="conum">(3)</b>
      .useValue(mockSolicitudRepository) <b class="conum">(4)</b>
      .compile(); <b class="conum">(5)</b>

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/solicitud (GET)', async () =&gt; { <b class="conum">(6)</b>
    return request(app.getHttpServer()).get('/solicitud').expect(200);
  });
});</pre>
</div>
</div>
<div class="colist arabic data-line-2381">
<ol>
<li>
<p>Mock del repositorio. Inicialmente sólo con una función de mock <code>find</code> vacía para pasar el test</p>
</li>
<li>
<p><strong>Módulo de solicitud</strong>. No olvidar cambiarlo. Al haber copiado el archivo de tests desde <code>app.e2e-spec.ts</code>, el valor viene a <code>AppModule</code></p>
</li>
<li>
<p>Repositorio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Repositorio que sustituye (mockea) al original. Usamos el creado en paso 1.</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
<li>
<p>Test a ejecutar. Comprueba que en la ruta raiz del controlador (<code>/solicitud</code>) se devuelve un código de estado HTTP de 200</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2383">
<p>Tras guardar los cambios vemos que aparece un nuevo error, esta vez relacionado con la autenticación. El error se debe a que los endpoints de los controladores incluyen guardas para proteger el acceso a través de JWT. Para los tests, burlaremos la guarda definida (<code>AuthGuuard('jwt')</code>). El archivo de testing ahora quedaría así:</p>
</div>
<div class="listingblock data-line-2386">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { SolicitudModule } from '../src/solicitud/solicitud.module';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Solicitud } from '../src/solicitud/entities/solicitud.entity';
import { AuthGuard } from '@nestjs/passport';

describe('SolicitudController (e2e)', () =&gt; {
  let app: INestApplication;
  const mockSolicitudRepository = {
    find: jest.fn(),
  };

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [SolicitudModule],
    })
      .overrideGuard(AuthGuard('jwt')) <b class="conum">(1)</b>
      .useValue('') <b class="conum">(2)</b>
      .overrideProvider(getRepositoryToken(Solicitud))
      .useValue(mockSolicitudRepository)
      .compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/solicitud (GET)', async () =&gt; {
    return request(app.getHttpServer()).get('/solicitud').expect(200);
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-2421">
<ol>
<li>
<p>Guarda que se va a modificar</p>
</li>
<li>
<p>Sustituir la guarda por nada para saltarla</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2423">
<p>Tras guardar los cambios veremos que pasan los tests.</p>
</div>
<div class="listingblock data-line-2426">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/solicitud.e2e-spec.ts
  SolicitudController (e2e)
    ✓ /solicitud (GET) (184 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        4.512 s
Ran all test suites matching /solicitud.e2e/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="paragraph data-line-2440">
<p>Este test se limita a comprobar que en la ruta <code>/solicitud</code> se devuelve un código de estado HTTP de 200.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2442">
<h2 id="_caso_de_uso_catálogo_de_productos">4. Caso de uso. Catálogo de productos</h2>
<div class="sectionbody">
<div class="paragraph data-line-2444">
<p>Para ilustrar los tests unitarios y de integración en este tutorial, así como el testing de controladores, servicios y uso de mocks, vamos a desarrollar un caso de uso sobre una API para un catálogo ficticio de productos. La API ofrecerá los endpoints para las operaciones básicas de crear un producto, obtener el listado de productos, obtener un producto a partir de su id, modificar y eliminar un producto.</p>
</div>
<div class="paragraph data-line-2446">
<p>Para no complicar demasiado el ejemplo pero que también dé juego, de cada producto se guarda:</p>
</div>
<div class="ulist data-line-2448">
<ul>
<li class="data-line-2448">
<p><code>id</code>: numérico</p>
</li>
<li class="data-line-2449">
<p><code>name</code>: string</p>
</li>
<li class="data-line-2450">
<p><code>brand</code>: string</p>
</li>
<li class="data-line-2451">
<p><code>category</code>: string</p>
</li>
<li class="data-line-2452">
<p><code>price</code>: numérico</p>
</li>
<li class="data-line-2453">
<p><code>url</code>: string</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2455">
<p>Partimos de un <a href="https://github.com/ualmtorres/testing-product-catalog/tree/base" data-href="https://github.com/ualmtorres/testing-product-catalog/tree/base">proyecto creado</a> y disponible en GitHub (rama <code>base</code>). Para más información sobre cómo crear y configurar el proyecto de este caso de uso consultar el <a href="#Anexo I. Configuración inicial del proyecto">[Anexo I. Configuración inicial del proyecto]</a></p>
</div>
<div class="admonitionblock note data-line-2458">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-2459">
<p>Para clonar la rama <code>base</code>, clonar el repositorio con este comando</p>
</div>
<div class="listingblock data-line-2462">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ git clone -b base https://github.com/ualmtorres/testing-product-catalog/tree/base</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock data-line-2469">
<div class="content">
<div class="title">Configuración de un servidor MySQL</div>
<div class="paragraph data-line-2470">
<p>Para trabajar localmente con persistencia necesitamos una base de datos a la que conectarnos. Para no tener que complicarnos con instalaciones y no acoplar el desarrollo a nuestro equipo utilizaremos una imagen Docker de MySQL 5.7. Crearemos una base de datos denominada <code>testing</code>. Usaremos las cuenta <code>root</code> con el password <code>secret</code></p>
</div>
<div class="listingblock data-line-2473">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ docker run --name testing_mysql -e MYSQL_ROOT_PASSWORD=secret -p 3306:3306 -d mysql:5.7 <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-2476">
<ol>
<li>
<p>Usaremos el password <code>secret</code> para la cuenta <code>root</code></p>
</li>
</ol>
</div>
<div class="paragraph data-line-2478">
<p>Tras unos instantes (algo más si la imagen de MySQL 5.7 no está descargada en el registro local de imágenes Docker) habrá un contenedor en ejecución con el nombre <code>testing_mysql</code>. Iniciaremos una sesión interactiva para crear una base de datos, a la que denominaremos <code>testing</code>.</p>
</div>
<div class="listingblock data-line-2481">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ docker exec -it testing_mysql bash
root@d0512407a21d:/# mysql -u root -p
Enter password: <b class="conum">(1)</b>
...
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt;
mysql&gt; create database testing; <b class="conum">(2)</b>
Query OK, 1 row affected (0.00 sec)</code></pre>
</div>
</div>
<div class="colist arabic data-line-2493">
<ol>
<li>
<p>Introducir el password <code>secret</code></p>
</li>
<li>
<p>Crear la base de datos <code>testing</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2 data-line-2496">
<h3 id="_primeros_tests_2">4.1. Primeros tests</h3>
<div class="paragraph data-line-2498">
<p>Comenzamos lanzando los tests sobre el proyecto creado con el comando siguiente</p>
</div>
<div class="listingblock data-line-2501">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test</code></pre>
</div>
</div>
<div class="paragraph data-line-2505">
<p>Tras unos instantes comprobamos que se han ejecutado tres suites de tests, pero sólo una se ha ejecutado con éxito, la de <code>src/app.controller.spec.ts</code>. Sin embargo, ni los tests del servicio (<code>src/product/product.service.spec.ts</code>), ni los del controlador (<code>src/product/product.controller.spec.ts</code>) han tenido éxito. En ambos casos nos indica que no están definido su <em>provider</em>.</p>
</div>
<div class="paragraph data-line-2507">
<p>A continuación veremos cómo resolver estos problemas y lo haremos desde el controlador hacia adentro. Es decir, primero haremos los tests unitarios del controlador y después los tests unitarios del servicio. Finalmente, dedicaremos una sección a realizar los tests de integración.</p>
</div>
</div>
<div class="sect2 data-line-2509">
<h3 id="_tests_del_controlador">4.2. Tests del controlador</h3>
<div class="paragraph data-line-2511">
<p>Los tests del controlador fallan porque mientras que en el arranque de la aplicación se cargan los módulos correctamente, al ejecutar los tests se utiliza módulos diferentes de los del entorno de ejecución. Y lo importante, <strong>inicialmente esos módulos no pueden resolver sus dependencias</strong>. Concretamente, lo que está ocurriendo es que el controlador no puede resolver en el entorno de pruebas su dependencia de <code>ProductService</code></p>
</div>
<div class="listingblock data-line-2514">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {} <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2521">
<ol>
<li>
<p>Dependencia del controlador respecto a <code>ProductService</code></p>
</li>
</ol>
</div>
<div class="paragraph data-line-2523">
<p>En el código siguiente del test del controlador, generado por el CLI de NestJS al generar el controlador, vemos que dentro de <code>beforeEach</code> se usa la clase <code>Test</code> y un método <code>createTestingModule</code>. Este método toma los mismos argumentos que se usan para crear un módulo (p.e. <code>imports</code>, <code>providers</code>, <code>controllers</code> &#8230;&#8203;). Tras definir el nuevo módulo (el de testing) y llamar al método <code>compile</code> se crea el módulo para testing con sus dependencias similar a los módulos creados para el entorno de ejecución.</p>
</div>
<div class="paragraph data-line-2525">
<p>Archivo <code>src/product/product.controller.spec.ts</code></p>
</div>
<div class="listingblock data-line-2527">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { ProductController } from './product.controller';
import { ProductService } from './product.service';

describe('ProductController', () =&gt; {
  let controller: ProductController;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({ <b class="conum">(1)</b>
      controllers: [ProductController],
      providers: [ProductService], <b class="conum">(2)</b>
    }).compile();

    controller = module.get&lt;ProductController&gt;(ProductController); <b class="conum">(3)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-2551">
<ol>
<li>
<p>Definición del módulo para el testing del controlador</p>
</li>
<li>
<p>Servicio a utilizar</p>
</li>
<li>
<p>Creación de una instancia del controller</p>
</li>
</ol>
</div>
<div class="sect3 data-line-2553">
<h4 id="_primer_paso_evitar_que_falle_el_test_4">4.2.1. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-2555">
<p>Seguiremos un enfoque progresivo para conseguir que nuestros tests funcionen. Se trata de ayudar a que en primer lugar desaparezcan los errores de las pruebas del controlador. Posteriormente, se irán refinando los tests.</p>
</div>
<div class="paragraph data-line-2557">
<p>El test del controlador falla porque el controlador no es capaz de resolver sus dependencias. Lo que haremos es sustituir el servicio original por un servicio de uso exclusivo en testing. Con esto, conseguiremos probar únicamente el controlador, aislándolo del servicio, que es la premisa de los tests unitarios: probar sólo una cosa en cada test.</p>
</div>
<div class="paragraph data-line-2559">
<p>Pasos:</p>
</div>
<div class="olist arabic data-line-2561">
<ol class="arabic">
<li class="data-line-2561">
<p>Crearemos un objeto <code>mockProductService</code> que sustituya (<em>mockee</em>) al servicio. Inicialmente <code>mockProductService</code> estará vacío. Posteriormente le iremos añadiendo los métodos falseados (<em>mockeados</em>).</p>
</li>
<li class="data-line-2562">
<p>Construir un módulo de testing que reemplace el servicio original del producto por el mockeado que hemos creado en el paso anterior.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-2565">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { ProductController } from './product.controller';
import { ProductService } from './product.service';

describe('ProductController', () =&gt; {
  let controller: ProductController;
  let mockProductService = {}; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProductController],
      providers: [ProductService],
    })
      .overrideProvider(ProductService) <b class="conum">(2)</b>
      .useValue(mockProductService) <b class="conum">(3)</b>
      .compile(); <b class="conum">(4)</b>

    controller = module.get&lt;ProductController&gt;(ProductController);
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-2594">
<ol>
<li>
<p>Mock del servicio. Inicialmente vacío para pasar el test</p>
</li>
<li>
<p>Servicio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Servicio que sustituye (mockea) al original. Usamos el creado en paso 1.</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2596">
<p>Lanzaremos ahora los tests unitarios, pero no los lanzaremos todos como hacíamos antes al ejecutar <code>npm run test</code>. En este proceso paulatino de creación de los tests unitarios nos ceñiremos sólo a los tests del controlador y además lo haremos en modo <code>watch</code>. Así, cada vez que hagamos cambios sobre el código se volverán a ejecutar los tests.</p>
</div>
<div class="listingblock data-line-2599">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ npm run test:watch

Watch Usage
 › Press a to run all tests.
 › Press f to run only failed tests.
 › Press p to filter by a filename regex pattern. <b class="conum">(1)</b>
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.</code></pre>
</div>
</div>
<div class="colist arabic data-line-2610">
<ol>
<li>
<p>Para ejecutar los tests de los nombres de archivo de acuerdo a una expresión regular</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2612">
<p>Pulsaremos <code>p</code> para indicar que sólo se pasen los tests a los archivos que sigan un patrón concreto de nombre de archivo. Introduciremos <code>product.controller</code> como patrón. Con esto, se pasarán los tests sólo al controlador y obtendremos un resultado como el siguiente:</p>
</div>
<div class="listingblock data-line-2615">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/product/product.controller.spec.ts
  ProductController
    ✓ should be defined (12 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        4.756 s, estimated 6 s
Ran all test suites matching /product.controller/i.

Watch Usage: Press w to show more.</code></pre>
</div>
</div>
<div class="paragraph data-line-2629">
<p>Objetivo cumplido!! Hemos conseguido hacer que desaparezca el error al ejecutar el test del conrtrolador. A continuación, comenzaremos a añadirle tests.</p>
</div>
</div>
<div class="sect3 data-line-2631">
<h4 id="_segundo_paso_añadir_tests_3">4.2.2. Segundo paso. Añadir tests</h4>
<div class="paragraph data-line-2633">
<p>Una vez que hemos configurado el módulo para que el test no falle mediante el mockeo del servicio, vamos a ir creando tests del controlador. Comenzaremos por el de creación de productos añadiendo este test después del test <code>should be defined</code>. Con este nuevo test definimos un nuevo DTO para crear un producto y esperamos que nos devuelva un objeto con un <code>id</code> (da igual el que sea. En el código de producción sería el <code>id</code> que generaría la base de datos) y el resto de campos coincidirán con los del DTO de creación de producto.</p>
</div>
<div class="listingblock data-line-2636">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should create a product', () =&gt; {
    const createProductDto = { <b class="conum">(1)</b>
      name: 'the-product',
      brand: 'the-brand',
      category: 'the-category',
      price: 10,
      url: 'http://product.com/the-product',
    };

    expect(controller.create(createProductDto)).toEqual({ <b class="conum">(2)</b>
      id: expect.any(Number),
      ...createProductDto,
    });
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2655">
<ol>
<li>
<p>DTO del producto a crear</p>
</li>
<li>
<p>Probamos que el producto creado consiste en un <code>id</code> junto a los datos proporcionados en el DTO para crear el producto</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2657">
<p>Tras guardar los cambios, como estamos en modo <code>watch</code> se volverán a pasar los tests y nos da un fallo: el método <code>create</code> no existe en el mock del servicio, tal y como se muestra a continuación:</p>
</div>
<div class="listingblock data-line-2660">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts"> FAIL  src/product/product.controller.spec.ts
  ProductController
    ✓ should be defined (12 ms)
    ✕ should create a product (4 ms) <b class="conum">(1)</b>

  ● ProductController › should create a product

    TypeError: this.productService.create is not a function <b class="conum">(2)</b>

      18 |   @Post()
      19 |   create(@Body() createProductDto: CreateProductDto) {
    &gt; 20 |     return this.productService.create(createProductDto); <b class="conum">(3)</b>
         |</code></pre>
</div>
</div>
<div class="colist arabic data-line-2677">
<ol>
<li>
<p>El test no pasa</p>
</li>
<li>
<p>El método <code>create</code> no existe en el mock del servicio (recordamos que estamos en el mockeado)</p>
</li>
<li>
<p>Línea en la que se provoca el error en el test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2679">
<p>El error se debe a que en la sección anterior creamos el mock del servicio del producto, pero lo creamos vacío, sin ningún método.</p>
</div>
<div class="listingblock data-line-2682">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductController', () =&gt; {
  let controller: ProductController;
  let mockProductService = {}; <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2689">
<ol>
<li>
<p>Mock del servicio creado vacío inicialmente</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2691">
<p>A continuación crearemos la implementación que mockea al método <code>create</code> del servicio. Se limitará a tomar un DTO y devolver un objeto con un <code>id</code> aleatorio (simulando lo que haría la base de datos) y el DTO.</p>
</div>
<div class="paragraph data-line-2693">
<p>Archivo <code>src/product/product.controller.spec.ts</code></p>
</div>
<div class="listingblock data-line-2695">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductController', () =&gt; {
  let controller: ProductController;
  let mockProductService = {
    create: jest.fn((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
        ...dto, <b class="conum">(3)</b>
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2711">
<ol>
<li>
<p>Método <code>create</code> mockeado.</p>
</li>
<li>
<p>id aleatorio</p>
</li>
<li>
<p>Incorporar el DTO del objeto a crear</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2713">
<p>Una vez realizados estos cambios, el test de crear un producto pasa correctamente.</p>
</div>
<div class="listingblock data-line-2716">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/product/product.controller.spec.ts
  ProductController
    ✓ should be defined (15 ms)
    ✓ should create a product (3 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        4.69 s</code></pre>
</div>
</div>
<div class="sidebarblock data-line-2729">
<div class="content">
<div class="title">Funciones de mock con <code>jest.fn()</code></div>
<div class="paragraph data-line-2730">
<p>Las funciones de mock se usan para inyectar o falsear código durante los tests.
<code>jest.fn()</code> crea una función de mock y opcionalmente puede tomar una implementación como parámetro.</p>
</div>
<div class="paragraph data-line-2733">
<p>Las funciones de mock tienen la propiedad <code>mock</code> que permite, entre otros, conocer los argumentos con los que fue llamada, obtener la cantidad de veces que fue llamada, y ver el valor de los argumentos en una llamada concreta, por ejemplo, en la tercera vez que fue llamada.</p>
</div>
<div class="paragraph data-line-2735">
<p>También tiene métodos interesantes como los siguientes:</p>
</div>
<div class="ulist data-line-2737">
<ul>
<li class="data-line-2737">
<p><code>mockReturnValue()</code>: Devuelve el valor que se pase como argumento</p>
</li>
<li class="data-line-2738">
<p><code>mockResolvedValue()</code>: Devuelve el valor resuelto por una promesa</p>
</li>
<li class="data-line-2739">
<p><code>mockImplementation()</code>: Acepta una función que es usada como implementación del mock</p>
</li>
<li class="data-line-2740">
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph data-line-2743">
<p>A continuación añadiremos otro test. Por ejemplo, añadiremos el test para actualizar un producto. Comenzaremos creando el test en <code>src/product/product.controller.spec.ts</code>. Lo añadiremos a continuación de los otros tests definidos.</p>
</div>
<div class="listingblock data-line-2746">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should update a product', () =&gt; {
    const updateProductDto = { <b class="conum">(1)</b>
      name: 'new-product',
      brand: 'new-brand',
      category: 'new-category',
      price: 100,
      url: 'http://product.com/the-new-product',
    };
    const productId = 2; <b class="conum">(2)</b>


    expect(controller.update(productId, updateProductDto)).toEqual({ <b class="conum">(3)</b>
      id: productId,
      ...updateProductDto,
    });
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2768">
<ol>
<li>
<p>DTO con los cambios del producto</p>
</li>
<li>
<p><code>id</code> del producto a modificar</p>
</li>
<li>
<p>Se espera que resultado de actualizar el producto sea el producto con el <code>id</code> y los datos actualizados</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2770">
<p>Tras guardar los cambios se volverán a pasar los tests y no pasará este test porque no está definido el método <code>update</code> en el mock del servicio.</p>
</div>
<div class="listingblock data-line-2773">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  src/product/product.controller.spec.ts
  ProductController
    ✓ should be defined (12 ms)
    ✓ should create a product (4 ms)
    ✕ should update a product (3 ms)

  ● ProductController › should update a product

    TypeError: this.productService.update is not a function</code></pre>
</div>
</div>
<div class="paragraph data-line-2785">
<p>Para solucionar este problema añadiremos la función <code>update</code> a <code>mockProductService</code>. Con los cambios, quedará así</p>
</div>
<div class="listingblock data-line-2788">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductController', () =&gt; {
  let controller: ProductController;
  let mockProductService = {
    create: jest.fn((dto) =&gt; {
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    update: jest.fn((id, dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: id,
        ...dto,
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2808">
<ol>
<li>
<p><code>update</code> devolverá el nuevo objeto modificado</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2810">
<p>Tras los cambios, los tests volverán a pasar.</p>
</div>
<div class="listingblock data-line-2813">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/product/product.controller.spec.ts
  ProductController
    ✓ should be defined (12 ms)
    ✓ should create a product (4 ms)
    ✓ should update a product (4 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        4.542 s, estimated 6 s</code></pre>
</div>
</div>
<div class="paragraph data-line-2826">
<p>Por último, es posible introducir una mejora al test para comprobar que el servicio fue llamado con los argumentos correctos. Esta comprobación va dirigida a conocer si el controlador introduce alguna anomalía al llamar al servicio. Con esto, no sólo nos aseguramos que el controlador hace su trabajo y devuelve los datos correctos, sino que también comprobamos que internamente hace bien su trabajo.</p>
</div>
<div class="paragraph data-line-2828">
<p>Tras los cambios el test quedaría así:</p>
</div>
<div class="listingblock data-line-2831">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should update a product', () =&gt; {
    const updateProductDto = {
      name: 'new-product',
      brand: 'new-brand',
      category: 'new-category',
      price: 100,
      url: 'http://product.com/the-new-product',
    };
    const productId = 2;


    expect(controller.update(productId, updateProductDto)).toEqual({
      id: productId,
      ...updateProductDto,
    });

    expect(mockProductService.update).toHaveBeenCalledWith(productId, updateProductDto); <b class="conum">(1)</b>
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2853">
<ol>
<li>
<p>Comprobación de que el servicio ha sido llamado con los argumentos correctos por parte del controlador</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2855">
<p>Al guardar, se volverán a pasar los tests y el cambio introducido funcionará correctamente, lo que permitirá validar que el controlador hace bien su trabajo.</p>
</div>
<div class="paragraph data-line-2857">
<p>Ahora, y de acuerdo con el informe de cobertura de tests, se trataría de ir añadiendo los tests que faltan (mostrar solciitudes, mostrar una solicitud y eliminar una solicitud). Los dejaremos para más adelante y ahora pasaremos a ver cómo llevar el mock del servicio a una clase aparte para no tenerlo mezclado con el test del controlador.</p>
</div>
</div>
<div class="sect3 data-line-2859">
<h4 id="_tercer_paso_llevar_el_mock_del_servicio_a_una_clase_2">4.2.3. Tercer paso. Llevar el mock del servicio a una clase</h4>
<div class="paragraph data-line-2861">
<p>Hasta ahora hemos mockeado el servicio en la misma clase de testing. Aquí veremos como refactorizar el archivo de testing sacando el mock a una clase aparte. Concretamente, se trata de llevar el contenido de los métodos de <code>mockSolicitudService</code> a métodos en una clase nueva.</p>
</div>
<div class="paragraph data-line-2863">
<p>Partimos del servicio mockeado en la propia clase, que recordamos que tenía esta forma:</p>
</div>
<div class="listingblock data-line-2866">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">...
  let mockSolicitudService = {
    create: jest.fn((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    update: jest.fn((id, dto) =&gt; { <b class="conum">(2)</b>
      return {
        id: id,
        ...dto,
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-2885">
<ol>
<li>
<p>Función de mock para crear solicitudes</p>
</li>
<li>
<p>Función de mock para modificar solicitudes</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2887">
<p>Comenzamos generando la clase que actuará como mock del servicio con el CLI de NestJS. La situaremos en la misma carpeta que el resto de componentes del producto.</p>
</div>
<div class="listingblock data-line-2890">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ nest g class solicitud/SolicitudServiceMock --no-spec <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-2893">
<ol>
<li>
<p>Incluimos el parámetro <code>--no-spec</code> para que no cree el archivo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2895">
<p>Esta clase estará inicialmente vacía:</p>
</div>
<div class="listingblock data-line-2898">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">export class SolicitudServiceMock {}</code></pre>
</div>
</div>
<div class="paragraph data-line-2902">
<p>Ahora se trata de traer a esta nueva clase de mock el código que había en los métodos <code>create</code> y <code>update</code> del objeto <code>mockSolicitudService</code> en el archivo de testing del controlador. Para ello, crearemos en la clase dos métodos <code>create</code> y <code>update</code> en los que incluiremos el código de mocking que ya teníamos. No obstante, renombraremos los DTO para darle una mayor semántica. Además, haremos que los métodos devuelvan promesas, tal y como lo hacen en el servicio real.</p>
</div>
<div class="paragraph data-line-2904">
<p>La clase que mockea al servicio ahora quedará así:</p>
</div>
<div class="listingblock data-line-2907">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { CreateSolicitudDto } from './dto/create-solicitud.dto';
import { Solicitud } from './entities/solicitud.entity';
import { UpdateSolicitudDto } from './dto/update-solicitud.dto';
export class SolicitudServiceMock {
  async create(createSolicitudDto: CreateSolicitudDto): Promise&lt;Solicitud&gt; { <b class="conum">(1)</b>
    return Promise.resolve({ <b class="conum">(2)</b>
      id: Math.random() * (1000 - 1) + 1,
      ...createSolicitudDto,
    });
  }

  async update(
    id: number,
    updateSolicitudDto: UpdateSolicitudDto,
  ): Promise&lt;Solicitud&gt; { <b class="conum">(3)</b>
    return Promise.resolve({ <b class="conum">(4)</b>
      id: id,
      ...updateSolicitudDto,
    }) as Promise&lt;Solicitud&gt;; <b class="conum">(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-2935">
<ol>
<li>
<p>Método <code>create</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudService</code></p>
</li>
<li>
<p>Método <code>update</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockSolicitudService</code></p>
</li>
<li>
<p>Forzamos el casting de la respuesta porque no pueden inferir que el tipo que devolvemos es correcto.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2937">
<p>Una vez que disponemos de la clase que mockea el servicio, <strong>haremos los cambios en el archivo de tests del controlador para que use esta clase mockeada en lugar de la variable <code>mockSolicitudService</code></strong>, que es la que contenía la implementación de los mocks.</p>
</div>
<div class="admonitionblock note data-line-2940">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-2941">
<p>La inyección de dependencias de NestJS permite que podamos sustituir el servicio que se usa para ejecutar los tests. El uso de mocks permite probar sólo una parte del código haciendo que el resto ofrezca valores falseados/generados. Esto, además de permitirnos un mayor control en el proceso de testing, acelera la ejecución de los tests, ya que el servicio ya no tiene que usar la base de datos (que siempre ofrece mayor latencia) para realizar su trabajo en el testing del controlador.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2944">
<p>Hay que hacer varios cambios:</p>
</div>
<div class="olist arabic data-line-2946">
<ol class="arabic">
<li class="data-line-2946">
<p>Declarar una variable <code>service</code> de tipo <code>SolicitudService</code></p>
</li>
<li class="data-line-2947">
<p>Definir un <code>SolicitudServiceProvider</code> que mockee el provider <code>SolicitudService</code></p>
</li>
<li class="data-line-2948">
<p>Incorporar el <code>ProductServiceProvider</code> a la lista de providers del módulo de testing</p>
</li>
<li class="data-line-2949">
<p>Usar la clase de mock para construir el módulo de testing</p>
</li>
<li class="data-line-2950">
<p>Inicializar la variable <code>service</code> al servicio del producto. Como <code>ProductService</code> está mockeado realmente no usará la implementación original</p>
</li>
<li class="data-line-2951">
<p>Cambiar los tests a asíncronos</p>
</li>
<li class="data-line-2952">
<p>Añadir <code>await</code> a las llamadas a los métodos del controlador</p>
</li>
<li class="data-line-2953">
<p>Usar espías de métodos si usamos métodos como <code>toHaveBeenCalledWith</code></p>
</li>
</ol>
</div>
<div class="listingblock data-line-2956">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { SolicitudController } from './solicitud.controller';
import { SolicitudService } from './solicitud.service';
import { CreateSolicitudDto } from './dto/create-solicitud.dto';
import { UpdateSolicitudDto } from './dto/update-solicitud.dto';
import { of } from 'rxjs';
import { SolicitudServiceMock } from './solicitud-service-mock';

describe('SolicitudController', () =&gt; {
  let controller: SolicitudController;
  let service: SolicitudService; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const SolicitudServiceProvider = { <b class="conum">(2)</b>
      provide: SolicitudService,
      useClass: SolicitudServiceMock,
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [SolicitudController],
      providers: [SolicitudService, SolicitudServiceProvider], <b class="conum">(3)</b>
    })
      .overrideProvider(SolicitudService)
      .useClass(SolicitudServiceMock) <b class="conum">(4)</b>
      .compile();

    controller = module.get&lt;SolicitudController&gt;(SolicitudController);
    service = module.get&lt;SolicitudService&gt;(SolicitudService); <b class="conum">(5)</b>
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });

  it('should create a solicitud', async () =&gt; { <b class="conum">(6)</b>
    const createSolicitudDto: CreateSolicitudDto = {
      nombre: 'John Doe',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };

    expect(await controller.create(createSolicitudDto)).toEqual({ <b class="conum">(7)</b>
      id: expect.any(Number),
      ...createSolicitudDto,
    });
  });

  it('should update a solicitud', async () =&gt; { <b class="conum">(8)</b>
    const updateSolicitudDto: UpdateSolicitudDto = {
      nombre: 'John Smith',
      cargo: 'Assistant Professor',
      unidad: 'Informatics Department',
      telefono: '1234',
      email: 'john.doe@gmail.com',
      tipo: '',
      nombreActividad: '',
      start: undefined,
      end: undefined,
      dia: '',
      horaInicio: '',
      horaFin: '',
    };
    const solicitudId = 1;

    expect(await controller.update(solicitudId, updateSolicitudDto)).toEqual({ <b class="conum">(9)</b>
      id: solicitudId,
      ...updateSolicitudDto,
    });

    const updateSpy = jest.spyOn(service, 'update'); <b class="conum">(10)</b>
    controller.update(solicitudId, updateSolicitudDto); <b class="conum">(11)</b>

    expect(updateSpy).toHaveBeenCalledWith(solicitudId, updateSolicitudDto); <b class="conum">(12)</b>
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-3053">
<ol>
<li>
<p>Declaración del servicio</p>
</li>
<li>
<p><code>SolicitudServiceProvider</code> mockea el provider <code>SolicitudService</code></p>
</li>
<li>
<p>Se añade <code>SolicitudServiceProvider</code> como otro provider</p>
</li>
<li>
<p>Inicialización del mock a la clase del mock del servicio (Inyección de dependencias)</p>
</li>
<li>
<p>Inicialización del servicio al servicio de la solicitud, que está mockeado</p>
</li>
<li>
<p>Caso de prueba asíncrono por el <code>await</code> en métodos dentrol del caso de prueba</p>
</li>
<li>
<p>Probamos que la solicitud se crea correctamente y devuelve los valores esperados. La ejecución se hace con <code>await</code></p>
</li>
<li>
<p>Caso de prueba asíncrono por el <code>await</code> en métodos dentro del caso de prueba</p>
</li>
<li>
<p>Probamos que la actualización de una solicitud se realiza correctamente y devuelve los valores esperados. La ejecución se hace con <code>await</code></p>
</li>
<li>
<p>Crear un espía para el método <code>update</code> en <code>service</code></p>
</li>
<li>
<p>Hacer una actualización de solicitud</p>
</li>
<li>
<p>Probamos que el servicio espiado ha sido llamado por el controlador con los parámetros adecuados</p>
</li>
</ol>
</div>
<div class="sidebarblock data-line-3056">
<div class="content">
<div class="title"><code>jest.spyOn()</code></div>
<div class="paragraph data-line-3057">
<p><code>jest.spyOn()</code> crea una función de mock similar a <code>jest.fn()</code> pero además, monitoriza/fisgonea las llamadas al método que se le proporcione.</p>
</div>
<div class="paragraph data-line-3059">
<p><code>jest.spyOn(objeto, nombre-de-método-a-espiar)</code> devuelve una función que se comporta como espía monitorizando las llamadas que se realicen al método del objeto que se pasen como argumentos.</p>
</div>
<div class="listingblock data-line-3062">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
let service: SolicitudService; <b class="conum">(1)</b>
...
service = module.get&lt;SolicitudService&gt;(SolicitudService); <b class="conum">(2)</b>
...

const updateSpy = jest.spyOn(service, 'update'); <b class="conum">(3)</b>
controller.update(solicitudId, updateSolicitudDto); <b class="conum">(4)</b>

expect(updateSpy).toHaveBeenCalledWith(solicitudId, updateSolicitudDto); <b class="conum">(5)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3080">
<ol>
<li>
<p>Declaración de un objeto <code>service</code></p>
</li>
<li>
<p>Inicialización del objeto <code>service</code> (a la clase del servicio)</p>
</li>
<li>
<p>Espiar el método <code>update</code> del objeto <code>service</code>. Ahora, <code>updateSpy</code>
monitoriza cada una de las llamadas que se hagan al método <code>update</code> del objeto <code>service</code>.</p>
</li>
<li>
<p>Llamar al método espiado (<code>update</code>)</p>
</li>
<li>
<p>Comprobar a través del espía (<code>updateSpy</code>) los argumentos con los que ha sido llamada la función espiada.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3082">
<p>La función espía intercepta/espía las llamadas que se hacen a un método de un objeto. Haciendo la analogía, el método <code>update</code> del objeto <code>service</code> está <em>pinchado</em>, como se <em>pinchan</em> los teléfonos en espionaje.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-3084">
<h3 id="_tests_del_servicio_2">4.3. Tests del servicio</h3>
<div class="paragraph data-line-3086">
<p>Una vez creados los tests del controlador procederemos a realizar los tests del servicio. De forma análoga a como hicimos con el controlador, que mockeaba el servicio del que dependía, en los tests del servicio también mockearamos sus dependencias. En el caso del servicio se mockea el repositorio, que es su dependencia.</p>
</div>
<div class="paragraph data-line-3088">
<p>Comenzamos lanzando los tests en modo <code>watch</code>, pero limitados al patrón <code>product.service</code></p>
</div>
<div class="listingblock data-line-3091">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:watch</code></pre>
</div>
</div>
<div class="paragraph data-line-3095">
<p>El resultado de los tests nos devolverá que no se pueden resolver las dependencias de <code>ProductService</code>. Esto se debe a que <code>ProductService</code> tiene una dependencia con el repositorio y no se puede resolver en el entorno de pruebas.</p>
</div>
<div class="listingblock data-line-3099">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product) private productsRepository: Repository&lt;Product&gt;, <b class="conum">(1)</b>
  ) {}
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3108">
<ol>
<li>
<p>Dependencia del servicio respecto del repositorio</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3110">
<p>De foma análoga a los tests del controlador, en el código siguiente del test del servicio, generado por el CLI de NestJS al generar el servicio, vemos que dentro de <code>beforeEach</code> se usa la clase <code>Test</code> y un método <code>createTestingModule</code>. Este método toma los mismos argumentos que se usan para crear un módulo (p.e. <code>imports</code>, <code>providers</code>, <code>controllers</code>, …​). Tras definir el nuevo módulo (el de testing) y llamar al método <code>compile</code> se crea el módulo con sus dependencias similar a los módulos creados para el entorno de ejecución.</p>
</div>
<div class="paragraph data-line-3113">
<p>Archivo <code>src/product/product.service.spec.ts</code></p>
</div>
<div class="listingblock data-line-3115">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductService', () =&gt; {
  let service: ProductService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({ <b class="conum">(1)</b>
      providers: [ProductService], <b class="conum">(2)</b>
    }).compile();

    service = module.get&lt;ProductService&gt;(ProductService); <b class="conum">(3)</b>
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3131">
<ol>
<li>
<p>Definición del módulo para el testing del servicio</p>
</li>
<li>
<p>Provider del servicio</p>
</li>
<li>
<p>Creación de una instancia del servicio</p>
</li>
</ol>
</div>
<div class="sect3 data-line-3133">
<h4 id="_primer_paso_evitar_que_falle_el_test_5">4.3.1. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-3135">
<p>Al igual que hicimos con el controlador, seguiremos un enfoque progresivo para conseguir que nuestros tests funcionen. Se trata de ayudar a que en primer lugar desaparezcan los errores de las pruebas del servicio. Posteriormente, se irán refinando los tests.</p>
</div>
<div class="paragraph data-line-3137">
<p>Inicialmente, el test del servicio falla porque el servicio no es capaz de resolver sus dependencias. Lo que haremos es sustituir el repositorio original por un repositorio de uso exclusivo en testing. Con esto, conseguiremos probar únicamente el servicio, aislándolo del repositorio, que es la premisa de los tests unitarios: probar sólo una cosa en cada test.</p>
</div>
<div class="paragraph data-line-3139">
<p>Pasos:</p>
</div>
<div class="olist arabic data-line-3141">
<ol class="arabic">
<li class="data-line-3141">
<p>Crearemos un objeto <code>mockProductsRepository</code> que sustituya (mockee) al repositorio. Inicialmente <code>mockProductsRepository</code> estará vacío. Posteriormente le iremos añadiendo los métodos falseados (mockeados).</p>
</li>
<li class="data-line-3142">
<p>Construir un módulo de testing que reemplace el repositorio original del producto por el mockeado que hemos creado en el paso anterior.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-3145">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { ProductService } from './product.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Product } from './entities/product.entity';

describe('ProductService', () =&gt; {
  let service: ProductService;
  let mockProductsRepository = {}; <b class="conum">(1)</b>

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProductService,
        { <b class="conum">(2)</b>
          provide: getRepositoryToken(Product), <b class="conum">(3)</b>
          useValue: mockProductsRepository, <b class="conum">(4)</b>
        },
      ],
    }).compile(); <b class="conum">(5)</b>

    service = module.get&lt;ProductService&gt;(ProductService);
  });

  it('should be defined', () =&gt; {
    expect(service).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-3178">
<ol>
<li>
<p>Mock del repositorio. Inicialmente vacío para pasar el test</p>
</li>
<li>
<p>Nuevo provider</p>
</li>
<li>
<p>Repositorio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Repositorio que sustituye (mockea) al original. Usamos el creado en el paso 1</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3180">
<p>Tras guardar los cambios ahora vemos que ya pasan los tests.</p>
</div>
<div class="listingblock data-line-3183">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/product/product.service.spec.ts (5.777 s)
  ProductService
    ✓ should be defined (12 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        6.522 s</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3194">
<h4 id="_segundo_paso_añadir_tests_4">4.3.2. Segundo paso. Añadir tests</h4>
<div class="paragraph data-line-3196">
<p>Una vez que hemos configurado el módulo para que el test no falle mediante el mockeo del repositorio, vamos a ir creando tests del servicio. Comenzaremos por el de creación de productos añadiendo este test después del test <code>should be defined</code>. Con este nuevo test definimos un nuevo DTO para crear un producto y esperamos que nos devuelva un objeto con un id (da igual el que sea. En el código de producción sería el <code>id</code> que generaría la base de datos) y el resto de campos coincidirán con los del DTO de creación de producto.</p>
</div>
<div class="listingblock data-line-3199">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  it('should create a product', async () =&gt; {
    const createProductDto = { <b class="conum">(1)</b>
      name: 'the-product',
      brand: 'the-brand',
      category: 'the-category',
      price: 10,
      url: 'http://product.com/the-product',
    };

    expect(await service.create(createProductDto)).toEqual({ <b class="conum">(2)</b>
      id: expect.any(Number),
      ...createProductDto,
    });
  });
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3218">
<ol>
<li>
<p>DTO del producto a crear</p>
</li>
<li>
<p>Probamos que el producto creado consiste en un <code>id</code> junto a los datos proporcionados en el DTO para crear el producto</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3220">
<p>Tras guardar los cambios, como estamos en modo <code>watch</code> se volverán a pasar los tests y nos da un fallo: el método <code>create</code> no existe en el mock del repositorio, tal y como se muestra a continuación:</p>
</div>
<div class="listingblock data-line-3223">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  src/product/product.service.spec.ts
  ProductService
    ✓ should be defined (11 ms)
    ✕ should create a product (3 ms) <b class="conum">(1)</b>

  ● ProductService › should create a product

    TypeError: this.productsRepository.save is not a function <b class="conum">(2)</b>

      12 |   ) {}
      13 |   async create(createProductDto: CreateProductDto): Promise&lt;Product&gt; {
    &gt; 14 |     return await this.productsRepository.save(createProductDto); <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-3239">
<ol>
<li>
<p>El test no pasa</p>
</li>
<li>
<p>El método <code>create</code> no existe en el mock del repositorio (recordamos que estamos en el mockeado)</p>
</li>
<li>
<p>Línea en la que se provoca el error en el test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3241">
<p>El error se debe a que en la sección anterior creamos el mock del repositorio del producto pero lo creamos vacío, sin ningún método.</p>
</div>
<div class="listingblock data-line-3244">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductService', () =&gt; {
  let service: ProductService;
  let mockProductsRepository = {}; <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3251">
<ol>
<li>
<p>Mock del repositorio creado vacío inicialmente</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3253">
<p>A continuación crearemos la implementación que mockea al método <code>create</code> del repositorio. Se limitará a tomar un DTO y devolver un objeto con un <code>id</code> aleatorio  (simulando lo que haría la base de datos) y el DTO.</p>
</div>
<div class="paragraph data-line-3255">
<p>Archivo <code>src/product/product.service.spec.ts</code></p>
</div>
<div class="listingblock data-line-3258">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductService', () =&gt; {
  let service: ProductService;
  let mockProductsRepository = {
    create: jest.fn().mockImplementation((dto) =&gt; { &lt;1&lt;
      return {
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
        ...dto, <b class="conum">(3)</b>
      };
    }),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3274">
<ol>
<li>
<p>Método create mockeado.</p>
</li>
<li>
<p><code>id</code> aleatorio</p>
</li>
<li>
<p>Incorporar el DTO del objeto a crear</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3276">
<p>Una vez realizados estos cambios, el test de crear un producto sigue sin pasar correctamente. Nos indica que el método <code>save</code> no está implementado en el mock del repositorio. Esto se debe a que hay una referencia explícita al método <code>save</code> en la implementación del método <code>create</code> en el servicio.</p>
</div>
<div class="listingblock data-line-3279">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  async create(createProductDto: CreateProductDto): Promise&lt;Product&gt; {
    return await this.productsRepository.save(createProductDto); <b class="conum">(1)</b>
  }
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3286">
<ol>
<li>
<p>Referencia al método <code>save</code> del repositorio</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3288">
<p>Por tanto, tendremos que añadir la implementación del método <code>save</code> al mock de repositorio, quedando de esta manera:</p>
</div>
<div class="listingblock data-line-3291">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
describe('ProductService', () =&gt; {
  let service: ProductService;
  let mockProductsRepository = {
    create: jest.fn().mockImplementation((dto) =&gt; {
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    save: jest.fn().mockImplementation((newProduct) =&gt; <b class="conum">(1)</b>
      Promise.resolve({ <b class="conum">(2)</b>
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(3)</b>
        ...newProduct, <b class="conum">(4)</b>
      }),
    ),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3314">
<ol>
<li>
<p>Método <code>save</code> mockeado.</p>
</li>
<li>
<p>El método devuelve una promesa resuelta</p>
</li>
<li>
<p><code>id</code> aleatorio</p>
</li>
<li>
<p>Incorporar el DTO del objeto a guardar</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3316">
<p>Una vez realizados estos cambios, el test de crear un producto pasa correctamente.</p>
</div>
<div class="listingblock data-line-3319">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/product/product.service.spec.ts
  ProductService
    ✓ should be defined (11 ms)
    ✓ should create a product (4 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        4.233 s, estimated 6 s</code></pre>
</div>
</div>
<div class="paragraph data-line-3331">
<p>Ahora se trataría de ir añadiendo los tests que faltan (mostrar productos, mostrar un producto y eliminar un producto). Para no extender el tutorial, se dejan fuera del tutorial.</p>
</div>
</div>
<div class="sect3 data-line-3333">
<h4 id="_tercer_paso_llevar_el_mock_del_repositorio_a_una_clase_2">4.3.3. Tercer paso. Llevar el mock del repositorio a una clase</h4>
<div class="paragraph data-line-3335">
<p>Hasta ahora hemos mockeado el repositorio en la misma clase de testing. Aquí veremos como refactorizar el archivo de testing sacando el mock a una clase aparte. Concretamente se trata de llevar el contenido de los métodos de <code>mockProductsRepository</code> a métodos en una clase nueva.</p>
</div>
<div class="paragraph data-line-3337">
<p>Partimos del repositorio mockeado en la propia clase y tenía esta forma:</p>
</div>
<div class="listingblock data-line-3340">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
  let mockProductsRepository = {
    create: jest.fn().mockImplementation((dto) =&gt; {
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),
    save: jest.fn().mockImplementation((newProduct) =&gt; <b class="conum">(1)</b>
      Promise.resolve({ <b class="conum">(2)</b>
        id: Math.random() * (1000 - 1) + 1, <b class="conum">(3)</b>
        ...newProduct, <b class="conum">(4)</b>
      }),
    ),
  };
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3359">
<ol>
<li>
<p>Método para crear productos</p>
</li>
<li>
<p>Método para guardar productos</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3361">
<p>Comenzamos generando la clase con el CLI de NestJS</p>
</div>
<div class="listingblock data-line-3364">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ nest g class product/ProductRepositoryMock --no-spec <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-3367">
<ol>
<li>
<p>Incluimos el parámetro --no-spec para que no cree el archivo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3369">
<p>Esta clase estará inicialmente vacía:</p>
</div>
<div class="listingblock data-line-3372">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">$ export class ProductRepositoryMock {}</code></pre>
</div>
</div>
<div class="paragraph data-line-3376">
<p>Ahora se trata de traer a esta nueva clase de mock el código que había en los métodos <code>create</code> y <code>save</code> del objeto <code>ProductServiceMock</code> en el archivo de testing del servicio. Para ello, crearemos en la clase dos métodos <code>create</code> y <code>save</code> en los que incluiremos el código de mocking que ya teníamos. No obstante, renombraremos los DTO para darle una mayor semántica. Además, haremos que los métodos devuelvan promesas, tal y como lo hacen en el repositorio real.</p>
</div>
<div class="paragraph data-line-3378">
<p>La clase que mockea al repositorio ahora quedará así:</p>
</div>
<div class="listingblock data-line-3381">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">import { Product } from './entities/product.entity';
import { CreateProductDto } from './dto/create-product.dto';
export class ProductRepositoryMock {
  create(createProductDto: CreateProductDto): Promise&lt;Product&gt; { <b class="conum">(1)</b>
    return Promise.resolve({
      id: Math.random() * (1000 - 1) + 1, <b class="conum">(2)</b>
      ...createProductDto,
    });
  }
  save(product: Product): Promise&lt;Product&gt; { <b class="conum">(3)</b>
    return Promise.resolve({
      id: Math.random() * (1000 - 1) + 1, <b class="conum">(4)</b>
      ...product,
    });
  }
}</code></pre>
</div>
</div>
<div class="colist arabic data-line-3402">
<ol>
<li>
<p>Método <code>create</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockProductsRepository</code></p>
</li>
<li>
<p>Método <code>save</code> mockeado</p>
</li>
<li>
<p>Código traído desde <code>mockProductsRepository</code></p>
</li>
</ol>
</div>
<div class="paragraph data-line-3404">
<p>Una vez que disponemos de la clase que mockea el repositorio, <strong>haremos los cambios en el archivo de tests del servicio para que use esta clase mockeada en lugar de la variable <code>mockProductsRepository</code></strong>, que es la que contenía la implementación de los mocks. Basta con:</p>
</div>
<div class="olist arabic data-line-3406">
<ol class="arabic">
<li class="data-line-3406">
<p>Eliminar la variable <code>mockProductsRepository</code></p>
</li>
<li class="data-line-3407">
<p>Usar la clase de mock para construir el módulo de testing</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3409">
<p>La clase de testing quedaría así</p>
</div>
<div class="listingblock data-line-3412">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { ProductService } from './product.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Product } from './entities/product.entity';
import { ProductRepositoryMock } from './product-repository-mock';

describe('ProductService', () =&gt; {
  let service: ProductService;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProductService,
        {
          provide: getRepositoryToken(Product),
          useClass: ProductRepositoryMock, <b class="conum">(1)</b>
        },
      ],
    }).compile();

    service = module.get&lt;ProductService&gt;(ProductService);
  });

  it('should be defined', () =&gt; {
    expect(service).toBeDefined();
  });

  it('should create a product', async () =&gt; {
    const createProductDto = {
      name: 'the-product',
      brand: 'the-brand',
      category: 'the-category',
      price: 10,
      url: 'http://product.com/the-product',
    };

    expect(await service.create(createProductDto)).toEqual({
      id: expect.any(Number),
      ...createProductDto,
    });
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-3456">
<ol>
<li>
<p>Inicialización del mock a la clase del mock del repositorio</p>
</li>
</ol>
</div>
<div class="admonitionblock note data-line-3459">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-3460">
<p>La inyección de dependencias de NestJS permite que podamos sustituir el repositorio que se usa para ejecutar los tests. El uso de mocks permite probar sólo una parte del código haciendo que el resto ofrezca valores falseados/generados. Esto, además de permitirnos un mayor control en el proceso de testing, acelera la ejecución de los tests, ya que el servicio ya no tiene que usar la base de datos (que siempre ofrece mayor latencia) para realizar su trabajo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2 data-line-3463">
<h3 id="_tests_end_to_end_2">4.4. Tests end to end</h3>
<div class="paragraph data-line-3465">
<p>Este tipo de tests se centra más en la interacción entre clases y módulos a un nivel más alto, en la línea de cómo interactuarían los usuarios con la aplicación. Con esto podremos realizar la prueba de cada endpoint de la API. Para simular las llamadas HTTP NestJS usa <a href="https://github.com/visionmedia/supertest" data-href="https://github.com/visionmedia/supertest">Supertest</a> .</p>
</div>
<div class="admonitionblock tip data-line-3468">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph data-line-3469">
<p>Para el desarrollo de nuestros tests seguiremos apoyándonos en que NestJS permite la inyección de dependencias de forma que podremos mockear o sustituir componentes fácilmente en el entorno de pruebas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 data-line-3472">
<h4 id="_añadir_script_para_tests_e2e_en_modo_watch_2">4.4.1. Añadir script para tests e2e en modo <code>watch</code></h4>
<div class="paragraph data-line-3474">
<p>Podemos lanzar las pruebas e2e generadas al crear el proyecto con el CLI de NestJS. En <code>package.json</code> hay un script para ello: <code>test:e2e</code>. Pero antes de lanzar los tests vamos a introducir un script en <code>package.json</code> para que los tests e2e también se ejecuten en modo <code>watch</code>. Añadiremos los cambios al final del elemento <code>scripts</code>:</p>
</div>
<div class="paragraph data-line-3476">
<p>Archivo <code>package.json</code></p>
</div>
<div class="listingblock data-line-3479">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">...
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "test:e2e:watch": "jest --config ./test/jest-e2e.json --watch" <b class="conum">(1)</b>
  },
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3499">
<ol>
<li>
<p>Nueva etiqueta <code>test:e2e:watch</code> para tests e2e en modo <code>watch</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3 data-line-3501">
<h4 id="_primer_paso_evitar_que_falle_el_test_6">4.4.2. Primer paso. Evitar que falle el test</h4>
<div class="paragraph data-line-3503">
<p>Comenzaremos haciendo una copia de <code>test/app.e2e-spec.ts</code>. La nueva copia se denominará <code>test/product.e2e-spec.ts</code>.</p>
</div>
<div class="admonitionblock note data-line-3506">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-3507">
<p>De forma predeterminada se ejecutarán como tests e2e todos los que incluyan <code>e2e-spec.ts</code> en su nombre de archivo. Esto se configura en el archivo <code>test/jest-e2e.json</code> y queda configurado automáticamente al crear el proyecto con el CLI de NestJS.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-3510">
<p>Si ejecutamos los tests e2e con el script <code>test:e2e:watch</code></p>
</div>
<div class="listingblock data-line-3513">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:e2e:watch</code></pre>
</div>
</div>
<div class="paragraph data-line-3517">
<p>indicando como patrón <code>product.e2e</code> veremos que se produce un error</p>
</div>
<div class="listingblock data-line-3520">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> FAIL  test/product.e2e-spec.ts
  ProductController (e2e)
    ✕ / (GET) (170 ms)

  ● ProductController (e2e) › / (GET)

    RepositoryNotFoundError: No repository for "Product" was found. Looks like this entity is not registered in current "default" connection?</code></pre>
</div>
</div>
<div class="paragraph data-line-3530">
<p>El error indica que el módulo de testing creado para la ocasión no es capaz de resolver las dependencias que hay sobre el repositorio de <code>Product</code>. De forma análoga a como hemos hecho con los tests del controlador y del servicio, hay que añadir un mock que permita resolver la dependencia existente. Lo más inmediato es hacer lo mínimo para que el test deje de ejecutarse con errores. A continuación se muestran los cambios realizados.</p>
</div>
<div class="paragraph data-line-3532">
<p>Archivo <code>test/product.e2e-spec.ts</code></p>
</div>
<div class="listingblock data-line-3533">
<div class="content">
<pre>import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Product } from '../src/product/entities/product.entity';
import { ProductModule } from '../src/product/product.module';

describe('ProductController (e2e)', () =&gt; {
  let app: INestApplication;
  const mockProductRepository = {
    find: jest.fn(), <b class="conum">(1)</b>
  };

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [ProductModule], <b class="conum">(2)</b>
    })
      .overrideProvider(getRepositoryToken(Product)) <b class="conum">(3)</b>
      .useValue(mockProductRepository) <b class="conum">(4)</b>
      .compile(); <b class="conum">(5)</b>

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/product (GET)', () =&gt; { <b class="conum">(6)</b>
    return request(app.getHttpServer())
      .get('/product')
      .expect(200);
  });
});</pre>
</div>
</div>
<div class="colist arabic data-line-3571">
<ol>
<li>
<p>Mock del repositorio. Inicialmente sólo con una función de mock <code>find</code> vacía para pasar el test</p>
</li>
<li>
<p><strong>Módulo de producto</strong>. No olvidar cambiarlo. Al haber copiado el archivo de tests desde <code>app.e2e-spec.ts</code>, el valor viene a <code>AppModule</code></p>
</li>
<li>
<p>Repositorio que se va a sustituir (mockear)</p>
</li>
<li>
<p>Repositorio que sustituye (mockea) al original. Usamos el creado en paso 1.</p>
</li>
<li>
<p>Construcción del módulo para testing</p>
</li>
<li>
<p>Test a ejecutar. Comprueba que en la ruta raiz del controlador (<code>/product</code>) se devuelve un código de estado HTTP de 200</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3573">
<p>Tras guardar los cambios veremos que pasan los tests.</p>
</div>
<div class="listingblock data-line-3576">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/product.e2e-spec.ts
  ProductController (e2e)
    ✓ /product (GET) (421 ms)

A worker process has failed to exit gracefully and has been force exited. This is likely caused by tests leaking due to improper teardown. Try running with --detectOpenHandles to find leaks.
Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        5.513 s</code></pre>
</div>
</div>
<div class="paragraph data-line-3588">
<p>Este test se limita a comprobar que en la ruta <code>/product</code> se devuelve un código de estado HTTP de 200.</p>
</div>
</div>
<div class="sect3 data-line-3590">
<h4 id="_segundo_paso_añadir_tests_5">4.4.3. Segundo paso. Añadir tests</h4>
<div class="paragraph data-line-3592">
<p>Comenzamos cambiando el único test existente siguiendo los pasos siguientes:</p>
</div>
<div class="olist arabic data-line-3594">
<ol class="arabic">
<li class="data-line-3594">
<p>Definir un banco de datos de prueba.</p>
</li>
<li class="data-line-3595">
<p>Implementar la función de mock <code>find</code> para que devuelva el banco de datos de prueba</p>
</li>
<li class="data-line-3596">
<p>Modificar el test para que compruebe que la llamada al <code>GET</code> devuelve el banco de datos de prueba</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3598">
<p>A continuación se muestra el nuevo archivo de pruebas <code>test/product.e2e-spec.ts</code> siguiendo los pasos anteriores:</p>
</div>
<div class="listingblock data-line-3601">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Product } from '../src/product/entities/product.entity';
import { ProductModule } from '../src/product/product.module';

describe('ProductController (e2e)', () =&gt; {
  let app: INestApplication;

  const mockProducts = [ <b class="conum">(1)</b>
    {
      id: 1,
      name: 'the-product-1',
      brand: 'the-brand-1',
      category: 'the-category-1',
      price: 10,
      url: 'http://product.com/the-product-1',
    },
    {
      id: 2,
      name: 'the-product-2',
      brand: 'the-brand-2',
      category: 'the-category-2',
      price: 20,
      url: 'http://product.com/the-product-2',
    },
  ];

  const mockProductRepository = {
        find: jest.fn().mockImplementation(() =&gt; Promise.resolve(mockProducts)), <b class="conum">(2)</b>
  };



  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [ProductModule],
    })
      .overrideProvider(getRepositoryToken(Product))
      .useValue(mockProductRepository)
      .compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/product (GET)', () =&gt; {
    return request(app.getHttpServer())
      .get('/product')
      .expect(200)
      .expect('Content-Type', /json/) <b class="conum">(3)</b>
      .expect(mockProducts); <b class="conum">(4)</b>
  });

  afterAll(async () =&gt; { <b class="conum">(5)</b>
    await app.close();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-3666">
<ol>
<li>
<p>Banco de datos de prueba</p>
</li>
<li>
<p>Función mock que devuelve los datos de prueba</p>
</li>
<li>
<p>Probamos que la respuesta viene en JSON</p>
</li>
<li>
<p>Probamos que la llamada a <code>GET /product</code> devuelve los datos de prueba</p>
</li>
<li>
<p>Cerrar la aplicación tras cada test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3668">
<p>Tras guardar los cambios, los tests pasan con éxito.</p>
</div>
<div class="listingblock data-line-3671">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/product.e2e-spec.ts
  ProductController (e2e)
    ✓ /product (GET) (396 ms)</code></pre>
</div>
</div>
<div class="admonitionblock note data-line-3678">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-3679">
<p>Más información sobre el modo de uso y las posibilidades de Supertest en la <a href="https://github.com/visionmedia/supertest" data-href="https://github.com/visionmedia/supertest">documentación oficial de Supertest</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-3682">
<p>Continuemos con un nuevo test para probar la creación de productos. Seguiremos estos pasos:</p>
</div>
<div class="olist arabic data-line-3684">
<ol class="arabic">
<li class="data-line-3684">
<p>Implementar las funciones de mock necesarias para crear un producto (<code>create</code> y <code>save</code>)</p>
</li>
<li class="data-line-3685">
<p>Implementar el caso de test</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3687">
<p>A continuación se muestra cómo queda el archivo de test <code>test/product.e2e-spec.ts</code></p>
</div>
<div class="listingblock data-line-3690">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Product } from '../src/product/entities/product.entity';
import { ProductModule } from '../src/product/product.module';
import { response } from 'express';

describe('ProductController (e2e)', () =&gt; {
  let app: INestApplication;

  const mockProducts = [
    {
      id: 1,
      name: 'the-product-1',
      brand: 'the-brand-1',
      category: 'the-category-1',
      price: 10,
      url: 'http://product.com/the-product-1',
    },
    {
      id: 2,
      name: 'the-product-2',
      brand: 'the-brand-2',
      category: 'the-category-2',
      price: 20,
      url: 'http://product.com/the-product-2',
    },
  ];

  const mockProductRepository = {
    find: jest.fn().mockImplementation(() =&gt; Promise.resolve(mockProducts)),

    create: jest.fn().mockImplementation((dto) =&gt; { <b class="conum">(1)</b>
      return {
        id: Math.random() * (1000 - 1) + 1,
        ...dto,
      };
    }),

    save: jest <b class="conum">(2)</b>
      .fn()
      .mockImplementation((newProduct) =&gt; Promise.resolve(newProduct)),
  };

  beforeEach(async () =&gt; {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [ProductModule],
    })
      .overrideProvider(getRepositoryToken(Product))
      .useValue(mockProductRepository)
      .compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/product (GET)', () =&gt; {
    return request(app.getHttpServer())
      .get('/product')
      .expect(200)
      .expect('Content-Type', /json/)
      .expect(mockProducts);
  });

  it('/product (POST)', () =&gt; { <b class="conum">(3)</b>
    const createProductDto = {
      name: 'the-product',
      brand: 'the-brand',
      category: 'the-category',
      price: 10,
      url: 'http://product.com/the-product',
    };

    return request(app.getHttpServer())
      .post('/product') <b class="conum">(4)</b>
      .send(createProductDto) <b class="conum">(5)</b>
      .expect(201) <b class="conum">(6)</b>
      .then((response) =&gt; { <b class="conum">(7)</b>
        expect(response.body).toEqual({
          id: expect.any(Number),
          ...createProductDto,
        });
      });
  });

  afterAll(async () =&gt; {
    await app.close();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-3788">
<ol>
<li>
<p>Función de mock <code>create</code></p>
</li>
<li>
<p>Función de mock <code>save</code></p>
</li>
<li>
<p>Test de creación de producto.</p>
</li>
<li>
<p><code>POST</code> en la ruta <code>/product</code></p>
</li>
<li>
<p>Creación del producto con el objeto <code>createProductDto</code> inicializado en el test</p>
</li>
<li>
<p>Comprobar que devuelve el código HTTP de producto creado</p>
</li>
<li>
<p>Comprobar que devuelve un objeto con los datos de creación y un <code>id</code> generado</p>
</li>
</ol>
</div>
<div class="paragraph data-line-3790">
<p>Tras guardar los cambios veremos que los tests pasan.</p>
</div>
<div class="listingblock data-line-3793">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  test/product.e2e-spec.ts
  ProductController (e2e)
    ✓ /product (GET) (308 ms)
    ✓ /users (POST) (29 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        5.623 s, estimated 9 s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-3805">
<h3 id="_cobertura_de_tests_2">4.5. Cobertura de tests</h3>
<div class="paragraph data-line-3807">
<p>Tras realizar los tests del controlador, del servicio y de integración cabe preguntarse la cobertura de tests que tenemos y cuáles son las partes del código del proyecto que aún están sin probar. Para ello lanzaremos la cobertura de tests con</p>
</div>
<div class="listingblock data-line-3810">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm run test:cov</code></pre>
</div>
</div>
<div class="paragraph data-line-3814">
<p>El informe de resultados del análisis de cobertura está en la carpeta <code>coverage/lcov-report</code>. Si abrimos <code>index.html</code> accederemos al informe.</p>
</div>
<div class="imageblock data-line-3816">
<div class="content">
<img src="./images/coberturaGeneral.png" alt="coberturaGeneral">
</div>
</div>
<div class="paragraph data-line-3818">
<p>En el informe vemos que la cobertura en el código de la carpeta <code>src</code> es del 43.33% y en la de la carpeta <code>src/product</code> es del 54.9%.</p>
</div>
<div class="paragraph data-line-3820">
<p>Al hacer clic sobre <code>src</code> accederemos al informe de cobertura de esa carpeta y observamos que se está teniendo en cuenta <code>app.module.ts</code> para el análisis de cobertura.</p>
</div>
<div class="imageblock data-line-3822">
<div class="content">
<img src="./images/coberturaSrc.png" alt="coberturaSrc">
</div>
</div>
<div class="paragraph data-line-3824">
<p>Análogamente, al hacer clic sobre <code>src/product</code> accederemos al informe de cobertura de esa carpeta y observamos que se está teniendo en cuenta <code>product.module.ts</code> para el análisis de cobertura.</p>
</div>
<div class="imageblock data-line-3826">
<div class="content">
<img src="./images/coberturaProduct.png" alt="coberturaProduct">
</div>
</div>
<div class="sect3 data-line-3828">
<h4 id="_ignorando_los_módulos_para_el_análisis_de_la_cobertura">4.5.1. Ignorando los módulos para el análisis de la cobertura</h4>
<div class="paragraph data-line-3830">
<p>A continuación excluiremos los archivos de módulo del estudio de cobertura siguiendo la configuración vista en la sección <a href="#_exclusión_de_archivos_de_la_cobertura_de_tests">Exclusión de archivos de la cobertura de tests</a>. Se trata de incluir en el elemento <code>jest</code> del archivo <code>pagkage.json</code> el código siguiente:</p>
</div>
<div class="listingblock data-line-3833">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">    "coveragePathIgnorePatterns": [
      "module.ts"
    ],</code></pre>
</div>
</div>
<div class="paragraph data-line-3839">
<p>Si tras retirar los archivos <code>.module.ts</code> del análisis volvemos a pasar la cobertura de tests, los porcentajes mejoran ya que se ignoran los archivos de módulo que no tienen ninguna prueba sobre ellos. Ahora la cobertura en el código de la carpeta <code>src</code> la pasado de 43.33% a 59.09% y en la de la carpeta <code>src/product</code> ha pasado de 54.9% a 65.11%.</p>
</div>
<div class="imageblock data-line-3841">
<div class="content">
<img src="./images/coberturaDespuesIgnorar.png" alt="coberturaDespuesIgnorar">
</div>
</div>
<div class="paragraph data-line-3843">
<p>Al entrar en la carpeta <code>src</code> se observa que ya no aparece el archivo <code>app.module.ts</code>.</p>
</div>
<div class="imageblock data-line-3845">
<div class="content">
<img src="./images/CoberturaSrcDespuesDeIgnorar.png" alt="CoberturaSrcDespuesDeIgnorar">
</div>
</div>
</div>
<div class="sect3 data-line-3847">
<h4 id="_análisis_de_la_cobertura">4.5.2. Análisis de la cobertura</h4>
<div class="paragraph data-line-3849">
<p>La cobertura nos da una indicación muy útil para determinar el código que aún no está probado. Por ejemplo, si en el informe de cobertura de la carpeta <code>coverage/lcov-report</code> analizamos la cobertura de <code>src/product/product.controller.ts</code>, observamos el código que aún está sin probar.</p>
</div>
<div class="imageblock data-line-3851">
<div class="content">
<img src="./images/coberturaProductController.png" alt="coberturaProductController">
</div>
</div>
<div class="paragraph data-line-3853">
<p>La figura nos da una indicación de los métodos en los que deberíamos centrar los esfuerzos de desarrollo de tests. Todo lo que aparece marcado en rojo es código sin tests asociados. Así, deberíamos dirigir el desarrollo de los nuevos tests a los métodos <code>findAll, findOne</code> y <code>remove</code> del controlador.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-3857">
<h2 id="_anexo_i_plugin_coverage_gutters">Anexo I. Plugin Coverage Gutters</h2>
<div class="sectionbody">
<div class="paragraph data-line-3859">
<p><a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters" data-href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a> es un plugin para Visual Studio Code que permite ver la cobertura de cada archivo mostrando su porcentaje en la barra de estado e indicando en verde y rojo sobre el código las líneas probadas por los tests y las no probadas.</p>
</div>
<div class="paragraph data-line-3861">
<p>Tras instalarlo aparecerá un botón <code>Watch</code> en la barra de estado que podremos activar para que muestre la cobertura del archivo abierto.</p>
</div>
<div class="imageblock data-line-3863">
<div class="content">
<img src="./images/CoverageGuttersBoton.png" alt="CoverageGuttersBoton">
</div>
</div>
<div class="paragraph data-line-3865">
<p>Tras pulsar el botón, si abrimos un archivo nos mostrará la cobertura directamente en Visual Studio Code. La figura siguiente muestra en verde las líneas probadas, en rojo las líneas no probadas y el porcentaje de cobertura en la barra de estado (50%).</p>
</div>
<div class="imageblock data-line-3867">
<div class="content">
<img src="./images/CoverageGuttersWatch.png" alt="CoverageGuttersWatch">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-3870">
<h2 id="_anexo_ii_configuración_inicial_del_proyecto">Anexo II. Configuración inicial del proyecto</h2>
<div class="sectionbody">
<div class="paragraph data-line-3872">
<p>Recordamos los pasos de creación de una API para un proyecto de ejemplo de un catálogo ficticio de productos. Generaremos también un <em>resource</em> en NestJS para que nos cree el módulo, servicio, controlador, entidad y DTOs. También instalaremos las dependencias de Swagger y TypeORM para MySQL.</p>
</div>
<div class="listingblock data-line-3875">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ nest new testing-product-catalog
$ cd testing-product-catalog
$ nest g resource product <b class="conum">(1)</b>
$ npm install --save @nestjs/swagger swagger-ui-express
$ npm install --save typeorm mysql</code></pre>
</div>
</div>
<div class="colist arabic data-line-3882">
<ol>
<li>
<p>En <em>What transport layer do you use?</em> seleccionamos <code>REST API</code> y en <em>Would you like to generate CRUD entry points?</em> seleccionamos <code>Yes</code></p>
</li>
</ol>
</div>
<div class="sect2 data-line-3884">
<h3 id="_creación_de_la_entidad">Creación de la entidad</h3>
<div class="paragraph data-line-3886">
<p>Archivo <code>product.entity.ts</code></p>
</div>
<div class="listingblock data-line-3888">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  brand: string;

  @Column()
  category: string;

  @Column()
  price: number;

  @Column()
  url: string;
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-3913">
<h3 id="_configuración_de_typeorm">Configuración de TypeORM</h3>
<div class="olist arabic data-line-3915">
<ol class="arabic">
<li class="data-line-3915">
<p>Creación de archivo <code>ormconfig.json</code>. Este archivo se almacena en la raíz del proyecto, junto al <code>package.json</code>.</p>
<div class="listingblock data-line-3919">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "type": "mysql",
  "host": "localhost",
  "port": 3306,
  "username": "root",
  "password": "secret",
  "database": "testing",
  "entities": ["dist/**/*.entity.js"],
  "synchronize": true
}</code></pre>
</div>
</div>
</li>
<li class="data-line-3932">
<p>Configuración de TypeORM en <code>app.module.ts</code></p>
<div class="listingblock data-line-3936">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Module({
  imports: [TypeOrmModule.forRoot(), ProductModule], <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-3942">
<ol>
<li>
<p>El método <code>forRoot()</code> carga la configuración de TypeORM. Al no pasarle ningún argumento, la toma del archivo <code>ormconfig.json</code></p>
</li>
</ol>
</div>
</li>
<li class="data-line-3944">
<p>Registro de repositorio <code>Product</code> en <code>product/product.module.ts</code></p>
<div class="listingblock data-line-3948">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">...
@Module({
  imports: [TypeOrmModule.forFeature([Product])],
...</code></pre>
</div>
</div>
</li>
<li class="data-line-3955">
<p>Creación del constructor del servicio en <code>product/product.service.ts</code> para inyectar el repositorio de <code>Product</code></p>
<div class="listingblock data-line-3959">
<div class="content">
<pre>...
@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product) private productsRepository: Repository&lt;Product&gt;,
  ) {}
...</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2 data-line-3969">
<h3 id="_configuración_de_swagger">Configuración de Swagger</h3>
<div class="paragraph data-line-3971">
<p>En <code>main.ts</code></p>
</div>
<div class="listingblock data-line-3974">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Configurar títulos de documnentación
  const options = new DocumentBuilder()
    .setTitle('Product catalog REST API')
    .setDescription('API REST de Product catalog')
    .setVersion('1.0')
    .build();
  const document = SwaggerModule.createDocument(app, options);

  // La ruta en que se sirve la documentación
  SwaggerModule.setup('docs', app, document);

  await app.listen(3000);
}
bootstrap();</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-3998">
<h3 id="_dtos">DTOs</h3>
<div class="paragraph data-line-4000">
<p>DTO <code>product/dto/create-product.dto.ts</code></p>
</div>
<div class="listingblock data-line-4002">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">export class CreateProductDto {
import { ApiProperty } from '@nestjs/swagger';

export class CreateProductDto {
  @ApiProperty({ example: 'the-product' })
  readonly name: string;

  @ApiProperty({ example: 'the-brand' })
  readonly brand: string;

  @ApiProperty({ example: 'the-category' })
  readonly category: string;

  @ApiProperty({ example: 99 })
  readonly price: number;

  @ApiProperty({ example: 'http://product.com/the-product' })
  readonly url: string;
}

}</code></pre>
</div>
</div>
<div class="paragraph data-line-4026">
<p>DTO <code>product/dto/update-product.dto.ts</code></p>
</div>
<div class="listingblock data-line-4029">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { CreateProductDto } from './create-product.dto';

export class UpdateProductDto extends CreateProductDto {}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-4035">
<h3 id="_implementación_de_los_métodos_del_servicio">Implementación de los métodos del servicio</h3>
<div class="paragraph data-line-4037">
<p>Archivo <code>product/product.service.ts</code></p>
</div>
<div class="listingblock data-line-4040">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import { Injectable } from '@nestjs/common';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Product } from './entities/product.entity';
import { Repository } from 'typeorm';

@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product) private productsRepository: Repository&lt;Product&gt;,
  ) {}
  async create(createProductDto: CreateProductDto): Promise&lt;Product&gt; {
    return await this.productsRepository.save(createProductDto);
  }

  async findAll(): Promise&lt;Product[]&gt; {
    return await this.productsRepository.find();
  }

  async findOne(id: number): Promise&lt;Product&gt; {
    return await this.productsRepository.findOne(id);
  }

  async update(
    id: number,
    updateProductDto: UpdateProductDto,
  ): Promise&lt;Product&gt; {
    let toUpdate = await this.productsRepository.findOne(id);
    let updated = Object.assign(toUpdate, updateProductDto);

    return await this.productsRepository.save(updated);
  }

  async remove(id: number): Promise&lt;Product&gt; {
    let toRemove = await this.productsRepository.findOne(id);
    let removedProducts = await this.productsRepository.remove(
      new Array(toRemove),
    );

    return removedProducts[0];
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-4087">
<h3 id="_adaptación_de_los_parámetros_del_controlador">Adaptación de los parámetros del controlador</h3>
<div class="paragraph data-line-4089">
<p>El CLI de NestJS genera los endpoints usando el <code>id</code> de tipo <code>string</code>. Sin embargo, como en la entidad <code>Product</code> hemos definido el <code>id</code> de tipo <code>number</code> hay que cambiar el tipo del parámetro <code>id</code> en los métodos del controlador para que sea de tipo <code>number</code>.</p>
</div>
<div class="listingblock data-line-4092">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ProductService } from './product.service';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Post()
  create(@Body() createProductDto: CreateProductDto) {
    return this.productService.create(createProductDto);
  }

  @Get()
  findAll() {
    return this.productService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.productService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: number, @Body() updateProductDto: UpdateProductDto) {
    return this.productService.update(id, updateProductDto);
  }

  @Delete(':id')
  remove(@Param('id') id: number) {
    return this.productService.remove(id);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4137">
<h2 id="_anexo_ii_bdd">Anexo II. BDD</h2>
<div class="sectionbody">
<div class="ulist data-line-4139">
<ul>
<li class="data-line-4139">
<p>npm install jest-cucumber --save-dev</p>
</li>
<li class="data-line-4140">
<p>Crear un archivo <code>tests/jest-bdd.json</code> con este contenido</p>
<div class="listingblock data-line-4144">
<div class="content">
<pre>{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testMatch": [
    "**/*.steps.ts"
  ],
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}</pre>
</div>
</div>
</li>
<li class="data-line-4158">
<p>En la configuración de jest de package.json:</p>
<div class="listingblock data-line-4162">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">...
  "jest": {
    ...
    "testRegex": [".*\\.spec\\.ts$", ".*\\.steps\\.ts$"], <b class="conum">(1)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic data-line-4169">
<ol>
<li>
<p>Modificamos la expresión regular para que también tome los <code>*.steps.ts</code></p>
</li>
</ol>
</div>
</li>
<li class="data-line-4171">
<p>En la configuración scripts de package.json</p>
<div class="listingblock data-line-4175">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">...
  "scripts": {
    ...
    "test:bdd": "jest --config ./test/jest-bdd.json" <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic data-line-4181">
<ol>
<li>
<p>Creamos una nueva entrada para ejecutar sólo los tests BDD</p>
</li>
</ol>
</div>
</li>
<li class="data-line-4183">
<p>Definición de la feature y escenario en test/features/hello.feature</p>
<div class="listingblock data-line-4187">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Feature: Logging in

    Scenario: Entering a correct password
        Given I have previously created a password
        When I enter my password correctly
        Then I should be granted access</code></pre>
</div>
</div>
</li>
<li class="data-line-4196">
<p>Código base de los pasos del test</p>
<div class="listingblock data-line-4200">
<div class="content">
<pre class="highlight"><code class="language-ts" data-lang="ts">// logging-in.steps.js

import { defineFeature, loadFeature } from 'jest-cucumber';

const feature = loadFeature('test/features/hello.feature'); <b class="conum">(1)</b>

defineFeature(feature, (test) =&gt; { <b class="conum">(2)</b>
  test('Entering a correct password', ({ given, when, then }) =&gt; {
    given('I have previously created a password', () =&gt; {});

    when('I enter my password correctly', () =&gt; {});

    then('I should be granted access', () =&gt; {});
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-4218">
<ol>
<li>
<p>Referencia al archivo de la especificación Gherkin</p>
</li>
<li>
<p>Código generado automáticamente (Ver nota de información)</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip data-line-4221">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph data-line-4222">
<p>Instalando en Visual Studio Code la extensión <code>Jest-cucumber code generator</code> se activa una opción en el menú emergente que se activa al seleccionar un escenario completo de un archivo <code>.feature</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note data-line-4226">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-4227">
<p>Otras extesiones interesantes para Visual Studio Code:</p>
</div>
<div class="ulist data-line-4229">
<ul>
<li class="data-line-4229">
<p>Cucumber (Gherkin) Full Support</p>
</li>
<li class="data-line-4230">
<p>Snippets and Syntax Highlight for Gherkin (Cucumber)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist data-line-4233">
<ul>
<li class="data-line-4233">
<p>Para ejecutar todos los tests (unitarios y BDD): <code>npm test</code></p>
</li>
<li class="data-line-4234">
<p>Para ejecutar sólo los tests BDD: <code>npm run test:bdd</code></p>
</li>
</ul>
</div>
<div class="paragraph data-line-4236">
<p>Enlace: <a href="https://github.com/bencompton/jest-cucumber#readme" class="undefined" data-href="https://github.com/bencompton/jest-cucumber#readme">https://github.com/bencompton/jest-cucumber#readme</a></p>
</div>
</div>
</div>
<div class="sect1 data-line-4238">
<h2 id="_anexo_iii_ejemplos_de_tests">Anexo III. Ejemplos de tests</h2>
<div class="sectionbody">
<div class="ulist data-line-4240">
<ul>
<li class="data-line-4240">
<p>Happy path</p>
<div class="ulist data-line-4242">
<ul>
<li class="data-line-4242">
<p>When transfer is with different currency, receiver gets using his own currency (12ms)</p>
</li>
<li class="data-line-4243">
<p>When transfer is valid, get back a positive result (13ms)</p>
</li>
<li class="data-line-4244">
<p>When transfer is valid, a mail is sent to the receiver (16ms)</p>
</li>
</ul>
</div>
</li>
<li class="data-line-4246">
<p>Missing inputs</p>
<div class="ulist data-line-4248">
<ul>
<li class="data-line-4248">
<p>When no amount specified, should throw invalid details error (17ms)</p>
</li>
<li class="data-line-4249">
<p>When no sender specified, should throw invalid details error (1/ms)</p>
</li>
<li class="data-line-4250">
<p>When no receiver specified, should throw invalid detalls error (16ms)</p>
</li>
<li class="data-line-4251">
<p>When no bank specified, should throw invalid details error (15ms)</p>
</li>
</ul>
</div>
</li>
<li class="data-line-4253">
<p>Post transfer actions</p>
<div class="ulist data-line-4255">
<ul>
<li class="data-line-4255">
<p>When transfer is successful, should send mail to receiver (13ms)</p>
</li>
<li class="data-line-4256">
<p>When transfer as successful, receiver balance should get topped up (14ms)</p>
</li>
<li class="data-line-4257">
<p>When transter is successful, sender balance is updated with the transfer amount (14ms)</p>
</li>
</ul>
</div>
</li>
<li class="data-line-4259">
<p>No credit</p>
<div class="ulist data-line-4261">
<ul>
<li class="data-line-4261">
<p>When user is deleted, should not approve the transfer (14ms)</p>
</li>
<li class="data-line-4262">
<p>When user has no credit, should not approve the transfer (15ms)</p>
</li>
<li class="data-line-4263">
<p>When receiver lives in forbidden country, should not approve the transfer (14ms)</p>
</li>
<li class="data-line-4264">
<p>When asking to transfer more than credit, the declined transfer does not appear sender history (12ms)</p>
</li>
</ul>
</div>
</li>
<li class="data-line-4266">
<p>By Countries</p>
<div class="ulist data-line-4268">
<ul>
<li class="data-line-4268">
<p>When sender from Italy sends a valid payment, transfer is approved (13ms)</p>
</li>
<li class="data-line-4269">
<p>When sender from India sends a valid payment, transfer is approved (10ms)</p>
</li>
<li class="data-line-4270">
<p>When sender from US sends a valid payment, transfer is approved (10ms)</p>
</li>
<li class="data-line-4271">
<p>When sender from Germany sends a valid payment, transfer is approved (10ms)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1 data-line-4273">
<h2 id="_domain_objects_vs_entities">Domain objects vs entities</h2>
<div class="sectionbody">
<div class="paragraph data-line-4275">
<p>Typically, the domain object defines the business object and it&#8217;s properties and methods. It&#8217;s used to manipulate and move the data within the processing system. The Entity object exists to take those domain properties and map them to a persistent storage object, such as a database table.</p>
</div>
<div class="paragraph data-line-4277">
<p>The terms are a bit vague I agree. I would use domain to refer to the business area you are dealing with. Like banking or insurance or what not. Then you have domain models. These are the things you deal with in that business domain, like for domain of banking you have accounts, customers, transfers etc. I would use term entity for referencing the class/POJO or the persisted / concrete version of a model.</p>
</div>
</div>
</div>
<div class="sect1 data-line-4279">
<h2 id="_sorry_cypress">Sorry Cypress</h2>
<div class="sectionbody">
<div class="ulist data-line-4281">
<ul>
<li class="data-line-4281">
<p>Docker-compose: <a href="https://raw.githubusercontent.com/sorry-cypress/sorry-cypress/master/docker-compose.full.yml" class="undefined" data-href="https://raw.githubusercontent.com/sorry-cypress/sorry-cypress/master/docker-compose.full.yml">https://raw.githubusercontent.com/sorry-cypress/sorry-cypress/master/docker-compose.full.yml</a></p>
</li>
<li class="data-line-4282">
<p>npm install cy2 cypress</p>
</li>
<li class="data-line-4283">
<p>Dar de alta el proyecto en localhost:1234. Usar ese id en el cypress.json del proyecto (en <code>projectId</code>).</p>
</li>
<li class="data-line-4284">
<p>export CYPRESS_API_URL="http://localhost:1234/"</p>
</li>
<li class="data-line-4285">
<p>./node_modules/cy2/bin/cy2 run --record --key secret --parallel --ci-build-id <code>date +%s</code></p>
</li>
<li class="data-line-4286">
<p>./node_modules/cy2/bin/cy2 run --record --key secret --parallel --ci-build-id "sip 0.2"</p>
</li>
<li class="data-line-4287">
<p>Hay que añadir 127.0.0.1 storage en /etc/hosts para que suba los videos</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1 data-line-4291">
<h2 id="_retales">Retales</h2>
<div class="sectionbody">
<div class="paragraph data-line-4293">
<p><strong>Añadir el servicio de Fizz Buzz al archivo de testing del controlador.</strong> Este paso es muy importante porque para el testing, NestJS usa otro entorno diferente al de ejecución. Esto hace que el controlador no pueda resolver de forma predererminada su dependencia con el servicio. Es decir, en el archivo de test del controlador no está añadido el servicio Fizzbuzz. Tenemos dos opciones: añadir el servicio en el elemento <code>providers</code> o cargar directamente el módulo que definimos al principio, y que ya incorporaba el controlador y el servicio. Esta última será la opción que utilizaremos aquí y que se muestra en el listado de <code>fizzbuzz/fizzbuzz.controller.spec.ts</code>.</p>
</div>
<div class="listingblock data-line-4297">
<div class="content">
<pre class="highlight"><code class="language-typescript" data-lang="typescript">import { Test, TestingModule } from '@nestjs/testing';
import { FizzbuzzController } from './fizzbuzz.controller';
import { FizzbuzzModule } from './fizzbuzz.module';

describe('FizzbuzzController', () =&gt; {
  let controller: FizzbuzzController;

  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      imports: [FizzbuzzModule], <b class="conum">(1)</b>
      //controllers: [FizzbuzzController], <b class="conum">(2)</b>
    }).compile();

    controller = module.get&lt;FizzbuzzController&gt;(FizzbuzzController);
  });

  it('should be defined', () =&gt; {
    expect(controller).toBeDefined();
  });
});</code></pre>
</div>
</div>
<div class="colist arabic data-line-4320">
<ol>
<li>
<p>Módulo añadido para incluir controlador y servicio en el test</p>
</li>
<li>
<p>Declaración insuficiente inicial (ahora comentada) en la que sólo se especificaba el controlador y no el servicio.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-4323">
<p>Si ahora ejecutamos los tests con <code>npm run test</code>, este será su resultado:</p>
</div>
<div class="listingblock data-line-4326">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> PASS  src/fizzbuzz/fizzbuzz.controller.spec.ts
 PASS  src/fizzbuzz/fizzbuzz.service.spec.ts
 PASS  src/app.controller.spec.ts

Test Suites: 3 passed, 3 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        2.63 s, estimated 3 s
Ran all test suites.</code></pre>
</div>
</div>
<div class="admonitionblock caution data-line-4339">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph data-line-4340">
<p>Si no hubiésemos añadido el servicio o el módulo (que incluye controlador y servicio) en <code>fizzbuzz/fizzbuzz.controller.spec.ts</code>, habríamos obtenido el siguiente error al ejecutar <code>npm run test</code>:</p>
</div>
<div class="listingblock data-line-4343">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">...
FAIL  src/fizzbuzz/fizzbuzz.controller.spec.ts

● FizzbuzzController › should be defined
    Nest cant resolve dependencies of the FizzbuzzController (?). Please make sure that the argument FizzbuzzService at index [0] is available in the RootTestModule context.

    Potential solutions:
    - If FizzbuzzService is a provider, is it part of the current RootTestModule?
    - If FizzbuzzService is exported from a separate @Module, is that module imported within RootTestModule?
      @Module({
        imports: [ /* the Module containing FizzbuzzService */ ]
      })
...</code></pre>
</div>
</div>
<div class="paragraph data-line-4358">
<p>Esto es una señal de que falta por incluir un servicio en la lista de servicios del archivo de tests.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-03-21 00:01:57 +0100
</div>
</div>
</body>
</html>